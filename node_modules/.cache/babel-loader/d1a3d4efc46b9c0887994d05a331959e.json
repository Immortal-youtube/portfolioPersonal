{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatSort = void 0;\n\nconst error_1 = require(\"./error\");\n/** @internal */\n\n\nfunction prepareDirection() {\n  let direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  const value = `${direction}`.toLowerCase();\n  if (isMeta(direction)) return direction;\n\n  switch (value) {\n    case 'ascending':\n    case 'asc':\n    case '1':\n      return 1;\n\n    case 'descending':\n    case 'desc':\n    case '-1':\n      return -1;\n\n    default:\n      throw new error_1.MongoInvalidArgumentError(`Invalid sort direction: ${JSON.stringify(direction)}`);\n  }\n}\n/** @internal */\n\n\nfunction isMeta(t) {\n  return typeof t === 'object' && t != null && '$meta' in t && typeof t.$meta === 'string';\n}\n/** @internal */\n\n\nfunction isPair(t) {\n  if (Array.isArray(t) && t.length === 2) {\n    try {\n      prepareDirection(t[1]);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  return false;\n}\n\nfunction isDeep(t) {\n  return Array.isArray(t) && Array.isArray(t[0]);\n}\n\nfunction isMap(t) {\n  return t instanceof Map && t.size > 0;\n}\n/** @internal */\n\n\nfunction pairToMap(v) {\n  return new Map([[`${v[0]}`, prepareDirection([v[1]])]]);\n}\n/** @internal */\n\n\nfunction deepToMap(t) {\n  const sortEntries = t.map(_ref => {\n    let [k, v] = _ref;\n    return [`${k}`, prepareDirection(v)];\n  });\n  return new Map(sortEntries);\n}\n/** @internal */\n\n\nfunction stringsToMap(t) {\n  const sortEntries = t.map(key => [`${key}`, 1]);\n  return new Map(sortEntries);\n}\n/** @internal */\n\n\nfunction objectToMap(t) {\n  const sortEntries = Object.entries(t).map(_ref2 => {\n    let [k, v] = _ref2;\n    return [`${k}`, prepareDirection(v)];\n  });\n  return new Map(sortEntries);\n}\n/** @internal */\n\n\nfunction mapToMap(t) {\n  const sortEntries = Array.from(t).map(_ref3 => {\n    let [k, v] = _ref3;\n    return [`${k}`, prepareDirection(v)];\n  });\n  return new Map(sortEntries);\n}\n/** converts a Sort type into a type that is valid for the server (SortForCmd) */\n\n\nfunction formatSort(sort, direction) {\n  if (sort == null) return undefined;\n  if (typeof sort === 'string') return new Map([[sort, prepareDirection(direction)]]);\n\n  if (typeof sort !== 'object') {\n    throw new error_1.MongoInvalidArgumentError(`Invalid sort format: ${JSON.stringify(sort)} Sort must be a valid object`);\n  }\n\n  if (!Array.isArray(sort)) {\n    return isMap(sort) ? mapToMap(sort) : Object.keys(sort).length ? objectToMap(sort) : undefined;\n  }\n\n  if (!sort.length) return undefined;\n  if (isDeep(sort)) return deepToMap(sort);\n  if (isPair(sort)) return pairToMap(sort);\n  return stringsToMap(sort);\n}\n\nexports.formatSort = formatSort;","map":{"version":3,"mappings":"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","names":["prepareDirection","direction","value","toLowerCase","isMeta","error_1","JSON","stringify","t","$meta","isPair","Array","isArray","length","e","isDeep","isMap","Map","size","pairToMap","v","deepToMap","sortEntries","map","k","stringsToMap","key","objectToMap","Object","entries","mapToMap","from","formatSort","sort","undefined","keys","exports"],"sources":["C:\\Users\\anshs\\OneDrive\\Documents\\Code\\WebDevelopement\\portfolioPersonal\\node_modules\\mongodb\\src\\sort.ts"],"sourcesContent":["import { MongoInvalidArgumentError } from './error';\n\n/** @public */\nexport type SortDirection =\n  | 1\n  | -1\n  | 'asc'\n  | 'desc'\n  | 'ascending'\n  | 'descending'\n  | { $meta: string };\n\n/** @public */\nexport type Sort =\n  | string\n  | Exclude<SortDirection, { $meta: string }>\n  | string[]\n  | { [key: string]: SortDirection }\n  | Map<string, SortDirection>\n  | [string, SortDirection][]\n  | [string, SortDirection];\n\n/** Below stricter types were created for sort that correspond with type that the cmd takes  */\n\n/** @internal */\nexport type SortDirectionForCmd = 1 | -1 | { $meta: string };\n\n/** @internal */\nexport type SortForCmd = Map<string, SortDirectionForCmd>;\n\n/** @internal */\ntype SortPairForCmd = [string, SortDirectionForCmd];\n\n/** @internal */\nfunction prepareDirection(direction: any = 1): SortDirectionForCmd {\n  const value = `${direction}`.toLowerCase();\n  if (isMeta(direction)) return direction;\n  switch (value) {\n    case 'ascending':\n    case 'asc':\n    case '1':\n      return 1;\n    case 'descending':\n    case 'desc':\n    case '-1':\n      return -1;\n    default:\n      throw new MongoInvalidArgumentError(`Invalid sort direction: ${JSON.stringify(direction)}`);\n  }\n}\n\n/** @internal */\nfunction isMeta(t: SortDirection): t is { $meta: string } {\n  return typeof t === 'object' && t != null && '$meta' in t && typeof t.$meta === 'string';\n}\n\n/** @internal */\nfunction isPair(t: Sort): t is [string, SortDirection] {\n  if (Array.isArray(t) && t.length === 2) {\n    try {\n      prepareDirection(t[1]);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  return false;\n}\n\nfunction isDeep(t: Sort): t is [string, SortDirection][] {\n  return Array.isArray(t) && Array.isArray(t[0]);\n}\n\nfunction isMap(t: Sort): t is Map<string, SortDirection> {\n  return t instanceof Map && t.size > 0;\n}\n\n/** @internal */\nfunction pairToMap(v: [string, SortDirection]): SortForCmd {\n  return new Map([[`${v[0]}`, prepareDirection([v[1]])]]);\n}\n\n/** @internal */\nfunction deepToMap(t: [string, SortDirection][]): SortForCmd {\n  const sortEntries: SortPairForCmd[] = t.map(([k, v]) => [`${k}`, prepareDirection(v)]);\n  return new Map(sortEntries);\n}\n\n/** @internal */\nfunction stringsToMap(t: string[]): SortForCmd {\n  const sortEntries: SortPairForCmd[] = t.map(key => [`${key}`, 1]);\n  return new Map(sortEntries);\n}\n\n/** @internal */\nfunction objectToMap(t: { [key: string]: SortDirection }): SortForCmd {\n  const sortEntries: SortPairForCmd[] = Object.entries(t).map(([k, v]) => [\n    `${k}`,\n    prepareDirection(v)\n  ]);\n  return new Map(sortEntries);\n}\n\n/** @internal */\nfunction mapToMap(t: Map<string, SortDirection>): SortForCmd {\n  const sortEntries: SortPairForCmd[] = Array.from(t).map(([k, v]) => [\n    `${k}`,\n    prepareDirection(v)\n  ]);\n  return new Map(sortEntries);\n}\n\n/** converts a Sort type into a type that is valid for the server (SortForCmd) */\nexport function formatSort(\n  sort: Sort | undefined,\n  direction?: SortDirection\n): SortForCmd | undefined {\n  if (sort == null) return undefined;\n  if (typeof sort === 'string') return new Map([[sort, prepareDirection(direction)]]);\n  if (typeof sort !== 'object') {\n    throw new MongoInvalidArgumentError(\n      `Invalid sort format: ${JSON.stringify(sort)} Sort must be a valid object`\n    );\n  }\n  if (!Array.isArray(sort)) {\n    return isMap(sort) ? mapToMap(sort) : Object.keys(sort).length ? objectToMap(sort) : undefined;\n  }\n  if (!sort.length) return undefined;\n  if (isDeep(sort)) return deepToMap(sort);\n  if (isPair(sort)) return pairToMap(sort);\n  return stringsToMap(sort);\n}\n"]},"metadata":{},"sourceType":"script"}