{"ast":null,"code":"import { toHex } from \"@aws-sdk/util-hex-encoding\";\nimport { normalizeProvider } from \"@aws-sdk/util-middleware\";\nimport { toUint8Array } from \"@aws-sdk/util-utf8\";\nimport { ALGORITHM_IDENTIFIER, ALGORITHM_QUERY_PARAM, AMZ_DATE_HEADER, AMZ_DATE_QUERY_PARAM, AUTH_HEADER, CREDENTIAL_QUERY_PARAM, EVENT_ALGORITHM_IDENTIFIER, EXPIRES_QUERY_PARAM, MAX_PRESIGNED_TTL, SHA256_HEADER, SIGNATURE_QUERY_PARAM, SIGNED_HEADERS_QUERY_PARAM, TOKEN_HEADER, TOKEN_QUERY_PARAM } from \"./constants\";\nimport { createScope, getSigningKey } from \"./credentialDerivation\";\nimport { getCanonicalHeaders } from \"./getCanonicalHeaders\";\nimport { getCanonicalQuery } from \"./getCanonicalQuery\";\nimport { getPayloadHash } from \"./getPayloadHash\";\nimport { hasHeader } from \"./headerUtil\";\nimport { moveHeadersToQuery } from \"./moveHeadersToQuery\";\nimport { prepareRequest } from \"./prepareRequest\";\nimport { iso8601 } from \"./utilDate\";\nexport class SignatureV4 {\n  constructor(_ref) {\n    let {\n      applyChecksum,\n      credentials,\n      region,\n      service,\n      sha256,\n      uriEscapePath = true\n    } = _ref;\n    this.service = service;\n    this.sha256 = sha256;\n    this.uriEscapePath = uriEscapePath;\n    this.applyChecksum = typeof applyChecksum === \"boolean\" ? applyChecksum : true;\n    this.regionProvider = normalizeProvider(region);\n    this.credentialProvider = normalizeProvider(credentials);\n  }\n\n  async presign(originalRequest) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      signingDate = new Date(),\n      expiresIn = 3600,\n      unsignableHeaders,\n      unhoistableHeaders,\n      signableHeaders,\n      signingRegion,\n      signingService\n    } = options;\n    const credentials = await this.credentialProvider();\n    this.validateResolvedCredentials(credentials);\n    const region = signingRegion ?? (await this.regionProvider());\n    const {\n      longDate,\n      shortDate\n    } = formatDate(signingDate);\n\n    if (expiresIn > MAX_PRESIGNED_TTL) {\n      return Promise.reject(\"Signature version 4 presigned URLs\" + \" must have an expiration date less than one week in\" + \" the future\");\n    }\n\n    const scope = createScope(shortDate, region, signingService ?? this.service);\n    const request = moveHeadersToQuery(prepareRequest(originalRequest), {\n      unhoistableHeaders\n    });\n\n    if (credentials.sessionToken) {\n      request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;\n    }\n\n    request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;\n    request.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;\n    request.query[AMZ_DATE_QUERY_PARAM] = longDate;\n    request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);\n    const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n    request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);\n    request.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));\n    return request;\n  }\n\n  async sign(toSign, options) {\n    if (typeof toSign === \"string\") {\n      return this.signString(toSign, options);\n    } else if (toSign.headers && toSign.payload) {\n      return this.signEvent(toSign, options);\n    } else {\n      return this.signRequest(toSign, options);\n    }\n  }\n\n  async signEvent(_ref2, _ref3) {\n    let {\n      headers,\n      payload\n    } = _ref2;\n    let {\n      signingDate = new Date(),\n      priorSignature,\n      signingRegion,\n      signingService\n    } = _ref3;\n    const region = signingRegion ?? (await this.regionProvider());\n    const {\n      shortDate,\n      longDate\n    } = formatDate(signingDate);\n    const scope = createScope(shortDate, region, signingService ?? this.service);\n    const hashedPayload = await getPayloadHash({\n      headers: {},\n      body: payload\n    }, this.sha256);\n    const hash = new this.sha256();\n    hash.update(headers);\n    const hashedHeaders = toHex(await hash.digest());\n    const stringToSign = [EVENT_ALGORITHM_IDENTIFIER, longDate, scope, priorSignature, hashedHeaders, hashedPayload].join(\"\\n\");\n    return this.signString(stringToSign, {\n      signingDate,\n      signingRegion: region,\n      signingService\n    });\n  }\n\n  async signString(stringToSign) {\n    let {\n      signingDate = new Date(),\n      signingRegion,\n      signingService\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const credentials = await this.credentialProvider();\n    this.validateResolvedCredentials(credentials);\n    const region = signingRegion ?? (await this.regionProvider());\n    const {\n      shortDate\n    } = formatDate(signingDate);\n    const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));\n    hash.update(toUint8Array(stringToSign));\n    return toHex(await hash.digest());\n  }\n\n  async signRequest(requestToSign) {\n    let {\n      signingDate = new Date(),\n      signableHeaders,\n      unsignableHeaders,\n      signingRegion,\n      signingService\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const credentials = await this.credentialProvider();\n    this.validateResolvedCredentials(credentials);\n    const region = signingRegion ?? (await this.regionProvider());\n    const request = prepareRequest(requestToSign);\n    const {\n      longDate,\n      shortDate\n    } = formatDate(signingDate);\n    const scope = createScope(shortDate, region, signingService ?? this.service);\n    request.headers[AMZ_DATE_HEADER] = longDate;\n\n    if (credentials.sessionToken) {\n      request.headers[TOKEN_HEADER] = credentials.sessionToken;\n    }\n\n    const payloadHash = await getPayloadHash(request, this.sha256);\n\n    if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {\n      request.headers[SHA256_HEADER] = payloadHash;\n    }\n\n    const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n    const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));\n    request.headers[AUTH_HEADER] = `${ALGORITHM_IDENTIFIER} ` + `Credential=${credentials.accessKeyId}/${scope}, ` + `SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, ` + `Signature=${signature}`;\n    return request;\n  }\n\n  createCanonicalRequest(request, canonicalHeaders, payloadHash) {\n    const sortedHeaders = Object.keys(canonicalHeaders).sort();\n    return `${request.method}\n${this.getCanonicalPath(request)}\n${getCanonicalQuery(request)}\n${sortedHeaders.map(name => `${name}:${canonicalHeaders[name]}`).join(\"\\n\")}\n\n${sortedHeaders.join(\";\")}\n${payloadHash}`;\n  }\n\n  async createStringToSign(longDate, credentialScope, canonicalRequest) {\n    const hash = new this.sha256();\n    hash.update(toUint8Array(canonicalRequest));\n    const hashedRequest = await hash.digest();\n    return `${ALGORITHM_IDENTIFIER}\n${longDate}\n${credentialScope}\n${toHex(hashedRequest)}`;\n  }\n\n  getCanonicalPath(_ref4) {\n    let {\n      path\n    } = _ref4;\n\n    if (this.uriEscapePath) {\n      const normalizedPathSegments = [];\n\n      for (const pathSegment of path.split(\"/\")) {\n        if (pathSegment?.length === 0) continue;\n        if (pathSegment === \".\") continue;\n\n        if (pathSegment === \"..\") {\n          normalizedPathSegments.pop();\n        } else {\n          normalizedPathSegments.push(pathSegment);\n        }\n      }\n\n      const normalizedPath = `${path?.startsWith(\"/\") ? \"/\" : \"\"}${normalizedPathSegments.join(\"/\")}${normalizedPathSegments.length > 0 && path?.endsWith(\"/\") ? \"/\" : \"\"}`;\n      const doubleEncoded = encodeURIComponent(normalizedPath);\n      return doubleEncoded.replace(/%2F/g, \"/\");\n    }\n\n    return path;\n  }\n\n  async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {\n    const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);\n    const hash = new this.sha256(await keyPromise);\n    hash.update(toUint8Array(stringToSign));\n    return toHex(await hash.digest());\n  }\n\n  getSigningKey(credentials, region, shortDate, service) {\n    return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);\n  }\n\n  validateResolvedCredentials(credentials) {\n    if (typeof credentials !== \"object\" || typeof credentials.accessKeyId !== \"string\" || typeof credentials.secretAccessKey !== \"string\") {\n      throw new Error(\"Resolved credential object is not valid\");\n    }\n  }\n\n}\n\nconst formatDate = now => {\n  const longDate = iso8601(now).replace(/[\\-:]/g, \"\");\n  return {\n    longDate,\n    shortDate: longDate.slice(0, 8)\n  };\n};\n\nconst getCanonicalHeaderList = headers => Object.keys(headers).sort().join(\";\");","map":{"version":3,"names":["toHex","normalizeProvider","toUint8Array","ALGORITHM_IDENTIFIER","ALGORITHM_QUERY_PARAM","AMZ_DATE_HEADER","AMZ_DATE_QUERY_PARAM","AUTH_HEADER","CREDENTIAL_QUERY_PARAM","EVENT_ALGORITHM_IDENTIFIER","EXPIRES_QUERY_PARAM","MAX_PRESIGNED_TTL","SHA256_HEADER","SIGNATURE_QUERY_PARAM","SIGNED_HEADERS_QUERY_PARAM","TOKEN_HEADER","TOKEN_QUERY_PARAM","createScope","getSigningKey","getCanonicalHeaders","getCanonicalQuery","getPayloadHash","hasHeader","moveHeadersToQuery","prepareRequest","iso8601","SignatureV4","constructor","applyChecksum","credentials","region","service","sha256","uriEscapePath","regionProvider","credentialProvider","presign","originalRequest","options","signingDate","Date","expiresIn","unsignableHeaders","unhoistableHeaders","signableHeaders","signingRegion","signingService","validateResolvedCredentials","longDate","shortDate","formatDate","Promise","reject","scope","request","sessionToken","query","accessKeyId","toString","canonicalHeaders","getCanonicalHeaderList","getSignature","createCanonicalRequest","sign","toSign","signString","headers","payload","signEvent","signRequest","priorSignature","hashedPayload","body","hash","update","hashedHeaders","digest","stringToSign","join","requestToSign","payloadHash","signature","sortedHeaders","Object","keys","sort","method","getCanonicalPath","map","name","createStringToSign","credentialScope","canonicalRequest","hashedRequest","path","normalizedPathSegments","pathSegment","split","length","pop","push","normalizedPath","startsWith","endsWith","doubleEncoded","encodeURIComponent","replace","keyPromise","secretAccessKey","Error","now","slice"],"sources":["C:/Users/anshs/OneDrive/Documents/Code/WebDevelopement/portfolioPersonal/node_modules/@aws-sdk/signature-v4/dist-es/SignatureV4.js"],"sourcesContent":["import { toHex } from \"@aws-sdk/util-hex-encoding\";\nimport { normalizeProvider } from \"@aws-sdk/util-middleware\";\nimport { toUint8Array } from \"@aws-sdk/util-utf8\";\nimport { ALGORITHM_IDENTIFIER, ALGORITHM_QUERY_PARAM, AMZ_DATE_HEADER, AMZ_DATE_QUERY_PARAM, AUTH_HEADER, CREDENTIAL_QUERY_PARAM, EVENT_ALGORITHM_IDENTIFIER, EXPIRES_QUERY_PARAM, MAX_PRESIGNED_TTL, SHA256_HEADER, SIGNATURE_QUERY_PARAM, SIGNED_HEADERS_QUERY_PARAM, TOKEN_HEADER, TOKEN_QUERY_PARAM, } from \"./constants\";\nimport { createScope, getSigningKey } from \"./credentialDerivation\";\nimport { getCanonicalHeaders } from \"./getCanonicalHeaders\";\nimport { getCanonicalQuery } from \"./getCanonicalQuery\";\nimport { getPayloadHash } from \"./getPayloadHash\";\nimport { hasHeader } from \"./headerUtil\";\nimport { moveHeadersToQuery } from \"./moveHeadersToQuery\";\nimport { prepareRequest } from \"./prepareRequest\";\nimport { iso8601 } from \"./utilDate\";\nexport class SignatureV4 {\n    constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true, }) {\n        this.service = service;\n        this.sha256 = sha256;\n        this.uriEscapePath = uriEscapePath;\n        this.applyChecksum = typeof applyChecksum === \"boolean\" ? applyChecksum : true;\n        this.regionProvider = normalizeProvider(region);\n        this.credentialProvider = normalizeProvider(credentials);\n    }\n    async presign(originalRequest, options = {}) {\n        const { signingDate = new Date(), expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, signingRegion, signingService, } = options;\n        const credentials = await this.credentialProvider();\n        this.validateResolvedCredentials(credentials);\n        const region = signingRegion ?? (await this.regionProvider());\n        const { longDate, shortDate } = formatDate(signingDate);\n        if (expiresIn > MAX_PRESIGNED_TTL) {\n            return Promise.reject(\"Signature version 4 presigned URLs\" + \" must have an expiration date less than one week in\" + \" the future\");\n        }\n        const scope = createScope(shortDate, region, signingService ?? this.service);\n        const request = moveHeadersToQuery(prepareRequest(originalRequest), { unhoistableHeaders });\n        if (credentials.sessionToken) {\n            request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;\n        }\n        request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;\n        request.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;\n        request.query[AMZ_DATE_QUERY_PARAM] = longDate;\n        request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);\n        const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n        request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);\n        request.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));\n        return request;\n    }\n    async sign(toSign, options) {\n        if (typeof toSign === \"string\") {\n            return this.signString(toSign, options);\n        }\n        else if (toSign.headers && toSign.payload) {\n            return this.signEvent(toSign, options);\n        }\n        else {\n            return this.signRequest(toSign, options);\n        }\n    }\n    async signEvent({ headers, payload }, { signingDate = new Date(), priorSignature, signingRegion, signingService }) {\n        const region = signingRegion ?? (await this.regionProvider());\n        const { shortDate, longDate } = formatDate(signingDate);\n        const scope = createScope(shortDate, region, signingService ?? this.service);\n        const hashedPayload = await getPayloadHash({ headers: {}, body: payload }, this.sha256);\n        const hash = new this.sha256();\n        hash.update(headers);\n        const hashedHeaders = toHex(await hash.digest());\n        const stringToSign = [\n            EVENT_ALGORITHM_IDENTIFIER,\n            longDate,\n            scope,\n            priorSignature,\n            hashedHeaders,\n            hashedPayload,\n        ].join(\"\\n\");\n        return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });\n    }\n    async signString(stringToSign, { signingDate = new Date(), signingRegion, signingService } = {}) {\n        const credentials = await this.credentialProvider();\n        this.validateResolvedCredentials(credentials);\n        const region = signingRegion ?? (await this.regionProvider());\n        const { shortDate } = formatDate(signingDate);\n        const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));\n        hash.update(toUint8Array(stringToSign));\n        return toHex(await hash.digest());\n    }\n    async signRequest(requestToSign, { signingDate = new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService, } = {}) {\n        const credentials = await this.credentialProvider();\n        this.validateResolvedCredentials(credentials);\n        const region = signingRegion ?? (await this.regionProvider());\n        const request = prepareRequest(requestToSign);\n        const { longDate, shortDate } = formatDate(signingDate);\n        const scope = createScope(shortDate, region, signingService ?? this.service);\n        request.headers[AMZ_DATE_HEADER] = longDate;\n        if (credentials.sessionToken) {\n            request.headers[TOKEN_HEADER] = credentials.sessionToken;\n        }\n        const payloadHash = await getPayloadHash(request, this.sha256);\n        if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {\n            request.headers[SHA256_HEADER] = payloadHash;\n        }\n        const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);\n        const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));\n        request.headers[AUTH_HEADER] =\n            `${ALGORITHM_IDENTIFIER} ` +\n                `Credential=${credentials.accessKeyId}/${scope}, ` +\n                `SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, ` +\n                `Signature=${signature}`;\n        return request;\n    }\n    createCanonicalRequest(request, canonicalHeaders, payloadHash) {\n        const sortedHeaders = Object.keys(canonicalHeaders).sort();\n        return `${request.method}\n${this.getCanonicalPath(request)}\n${getCanonicalQuery(request)}\n${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join(\"\\n\")}\n\n${sortedHeaders.join(\";\")}\n${payloadHash}`;\n    }\n    async createStringToSign(longDate, credentialScope, canonicalRequest) {\n        const hash = new this.sha256();\n        hash.update(toUint8Array(canonicalRequest));\n        const hashedRequest = await hash.digest();\n        return `${ALGORITHM_IDENTIFIER}\n${longDate}\n${credentialScope}\n${toHex(hashedRequest)}`;\n    }\n    getCanonicalPath({ path }) {\n        if (this.uriEscapePath) {\n            const normalizedPathSegments = [];\n            for (const pathSegment of path.split(\"/\")) {\n                if (pathSegment?.length === 0)\n                    continue;\n                if (pathSegment === \".\")\n                    continue;\n                if (pathSegment === \"..\") {\n                    normalizedPathSegments.pop();\n                }\n                else {\n                    normalizedPathSegments.push(pathSegment);\n                }\n            }\n            const normalizedPath = `${path?.startsWith(\"/\") ? \"/\" : \"\"}${normalizedPathSegments.join(\"/\")}${normalizedPathSegments.length > 0 && path?.endsWith(\"/\") ? \"/\" : \"\"}`;\n            const doubleEncoded = encodeURIComponent(normalizedPath);\n            return doubleEncoded.replace(/%2F/g, \"/\");\n        }\n        return path;\n    }\n    async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {\n        const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);\n        const hash = new this.sha256(await keyPromise);\n        hash.update(toUint8Array(stringToSign));\n        return toHex(await hash.digest());\n    }\n    getSigningKey(credentials, region, shortDate, service) {\n        return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);\n    }\n    validateResolvedCredentials(credentials) {\n        if (typeof credentials !== \"object\" ||\n            typeof credentials.accessKeyId !== \"string\" ||\n            typeof credentials.secretAccessKey !== \"string\") {\n            throw new Error(\"Resolved credential object is not valid\");\n        }\n    }\n}\nconst formatDate = (now) => {\n    const longDate = iso8601(now).replace(/[\\-:]/g, \"\");\n    return {\n        longDate,\n        shortDate: longDate.slice(0, 8),\n    };\n};\nconst getCanonicalHeaderList = (headers) => Object.keys(headers).sort().join(\";\");\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}