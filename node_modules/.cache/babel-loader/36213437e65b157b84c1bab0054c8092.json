{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InsertManyOperation = exports.InsertOneOperation = exports.InsertOperation = void 0;\n\nconst error_1 = require(\"../error\");\n\nconst write_concern_1 = require(\"../write_concern\");\n\nconst bulk_write_1 = require(\"./bulk_write\");\n\nconst command_1 = require(\"./command\");\n\nconst common_functions_1 = require(\"./common_functions\");\n\nconst operation_1 = require(\"./operation\");\n/** @internal */\n\n\nclass InsertOperation extends command_1.CommandOperation {\n  constructor(ns, documents, options) {\n    super(undefined, options);\n    this.options = { ...options,\n      checkKeys: options.checkKeys ?? false\n    };\n    this.ns = ns;\n    this.documents = documents;\n  }\n\n  execute(server, session, callback) {\n    const options = this.options ?? {};\n    const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n    const command = {\n      insert: this.ns.collection,\n      documents: this.documents,\n      ordered\n    };\n\n    if (typeof options.bypassDocumentValidation === 'boolean') {\n      command.bypassDocumentValidation = options.bypassDocumentValidation;\n    } // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n\n\n    if (options.comment !== undefined) {\n      command.comment = options.comment;\n    }\n\n    super.executeCommand(server, session, command, callback);\n  }\n\n}\n\nexports.InsertOperation = InsertOperation;\n\nclass InsertOneOperation extends InsertOperation {\n  constructor(collection, doc, options) {\n    super(collection.s.namespace, (0, common_functions_1.prepareDocs)(collection, [doc], options), options);\n  }\n\n  execute(server, session, callback) {\n    super.execute(server, session, (err, res) => {\n      if (err || res == null) return callback(err);\n      if (res.code) return callback(new error_1.MongoServerError(res));\n\n      if (res.writeErrors) {\n        // This should be a WriteError but we can't change it now because of error hierarchy\n        return callback(new error_1.MongoServerError(res.writeErrors[0]));\n      }\n\n      callback(undefined, {\n        acknowledged: this.writeConcern?.w !== 0 ?? true,\n        insertedId: this.documents[0]._id\n      });\n    });\n  }\n\n}\n\nexports.InsertOneOperation = InsertOneOperation;\n/** @internal */\n\nclass InsertManyOperation extends operation_1.AbstractOperation {\n  constructor(collection, docs, options) {\n    super(options);\n\n    if (!Array.isArray(docs)) {\n      throw new error_1.MongoInvalidArgumentError('Argument \"docs\" must be an array of documents');\n    }\n\n    this.options = options;\n    this.collection = collection;\n    this.docs = docs;\n  }\n\n  execute(server, session, callback) {\n    const coll = this.collection;\n    const options = { ...this.options,\n      ...this.bsonOptions,\n      readPreference: this.readPreference\n    };\n    const writeConcern = write_concern_1.WriteConcern.fromOptions(options);\n    const bulkWriteOperation = new bulk_write_1.BulkWriteOperation(coll, (0, common_functions_1.prepareDocs)(coll, this.docs, options).map(document => ({\n      insertOne: {\n        document\n      }\n    })), options);\n    bulkWriteOperation.execute(server, session, (err, res) => {\n      if (err || res == null) {\n        if (err && err.message === 'Operation must be an object with an operation key') {\n          err = new error_1.MongoInvalidArgumentError('Collection.insertMany() cannot be called with an array that has null/undefined values');\n        }\n\n        return callback(err);\n      }\n\n      callback(undefined, {\n        acknowledged: writeConcern?.w !== 0 ?? true,\n        insertedCount: res.insertedCount,\n        insertedIds: res.insertedIds\n      });\n    });\n  }\n\n}\n\nexports.InsertManyOperation = InsertManyOperation;\n(0, operation_1.defineAspects)(InsertOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(InsertOneOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(InsertManyOperation, [operation_1.Aspect.WRITE_OPERATION]);","map":{"version":3,"mappings":"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","names":["InsertOperation","command_1","constructor","ns","documents","options","undefined","checkKeys","execute","server","session","callback","ordered","command","insert","collection","bypassDocumentValidation","comment","executeCommand","exports","InsertOneOperation","doc","s","namespace","err","res","code","error_1","writeErrors","acknowledged","writeConcern","w","insertedId","_id","InsertManyOperation","operation_1","docs","Array","isArray","coll","bsonOptions","readPreference","write_concern_1","fromOptions","bulkWriteOperation","bulk_write_1","map","document","insertOne","message","insertedCount","insertedIds","RETRYABLE","WRITE_OPERATION"],"sources":["C:\\Users\\anshs\\OneDrive\\Documents\\Code\\WebDevelopement\\portfolioPersonal\\node_modules\\mongodb\\src\\operations\\insert.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport type { BulkWriteOptions } from '../bulk/common';\nimport type { Collection } from '../collection';\nimport { MongoInvalidArgumentError, MongoServerError } from '../error';\nimport type { InferIdType } from '../mongo_types';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport type { Callback, MongoDBNamespace } from '../utils';\nimport { WriteConcern } from '../write_concern';\nimport { BulkWriteOperation } from './bulk_write';\nimport { CommandOperation, CommandOperationOptions } from './command';\nimport { prepareDocs } from './common_functions';\nimport { AbstractOperation, Aspect, defineAspects } from './operation';\n\n/** @internal */\nexport class InsertOperation extends CommandOperation<Document> {\n  override options: BulkWriteOptions;\n  documents: Document[];\n\n  constructor(ns: MongoDBNamespace, documents: Document[], options: BulkWriteOptions) {\n    super(undefined, options);\n    this.options = { ...options, checkKeys: options.checkKeys ?? false };\n    this.ns = ns;\n    this.documents = documents;\n  }\n\n  override execute(\n    server: Server,\n    session: ClientSession | undefined,\n    callback: Callback<Document>\n  ): void {\n    const options = this.options ?? {};\n    const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n    const command: Document = {\n      insert: this.ns.collection,\n      documents: this.documents,\n      ordered\n    };\n\n    if (typeof options.bypassDocumentValidation === 'boolean') {\n      command.bypassDocumentValidation = options.bypassDocumentValidation;\n    }\n\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      command.comment = options.comment;\n    }\n\n    super.executeCommand(server, session, command, callback);\n  }\n}\n\n/** @public */\nexport interface InsertOneOptions extends CommandOperationOptions {\n  /** Allow driver to bypass schema validation in MongoDB 3.2 or higher. */\n  bypassDocumentValidation?: boolean;\n  /** Force server to assign _id values instead of driver. */\n  forceServerObjectId?: boolean;\n}\n\n/** @public */\nexport interface InsertOneResult<TSchema = Document> {\n  /** Indicates whether this write result was acknowledged. If not, then all other members of this result will be undefined */\n  acknowledged: boolean;\n  /** The identifier that was inserted. If the server generated the identifier, this value will be null as the driver does not have access to that data */\n  insertedId: InferIdType<TSchema>;\n}\n\nexport class InsertOneOperation extends InsertOperation {\n  constructor(collection: Collection, doc: Document, options: InsertOneOptions) {\n    super(collection.s.namespace, prepareDocs(collection, [doc], options), options);\n  }\n\n  override execute(\n    server: Server,\n    session: ClientSession | undefined,\n    callback: Callback<InsertOneResult>\n  ): void {\n    super.execute(server, session, (err, res) => {\n      if (err || res == null) return callback(err);\n      if (res.code) return callback(new MongoServerError(res));\n      if (res.writeErrors) {\n        // This should be a WriteError but we can't change it now because of error hierarchy\n        return callback(new MongoServerError(res.writeErrors[0]));\n      }\n\n      callback(undefined, {\n        acknowledged: this.writeConcern?.w !== 0 ?? true,\n        insertedId: this.documents[0]._id\n      });\n    });\n  }\n}\n\n/** @public */\nexport interface InsertManyResult<TSchema = Document> {\n  /** Indicates whether this write result was acknowledged. If not, then all other members of this result will be undefined */\n  acknowledged: boolean;\n  /** The number of inserted documents for this operations */\n  insertedCount: number;\n  /** Map of the index of the inserted document to the id of the inserted document */\n  insertedIds: { [key: number]: InferIdType<TSchema> };\n}\n\n/** @internal */\nexport class InsertManyOperation extends AbstractOperation<InsertManyResult> {\n  override options: BulkWriteOptions;\n  collection: Collection;\n  docs: Document[];\n\n  constructor(collection: Collection, docs: Document[], options: BulkWriteOptions) {\n    super(options);\n\n    if (!Array.isArray(docs)) {\n      throw new MongoInvalidArgumentError('Argument \"docs\" must be an array of documents');\n    }\n\n    this.options = options;\n    this.collection = collection;\n    this.docs = docs;\n  }\n\n  override execute(\n    server: Server,\n    session: ClientSession | undefined,\n    callback: Callback<InsertManyResult>\n  ): void {\n    const coll = this.collection;\n    const options = { ...this.options, ...this.bsonOptions, readPreference: this.readPreference };\n    const writeConcern = WriteConcern.fromOptions(options);\n    const bulkWriteOperation = new BulkWriteOperation(\n      coll,\n      prepareDocs(coll, this.docs, options).map(document => ({ insertOne: { document } })),\n      options\n    );\n\n    bulkWriteOperation.execute(server, session, (err, res) => {\n      if (err || res == null) {\n        if (err && err.message === 'Operation must be an object with an operation key') {\n          err = new MongoInvalidArgumentError(\n            'Collection.insertMany() cannot be called with an array that has null/undefined values'\n          );\n        }\n        return callback(err);\n      }\n      callback(undefined, {\n        acknowledged: writeConcern?.w !== 0 ?? true,\n        insertedCount: res.insertedCount,\n        insertedIds: res.insertedIds\n      });\n    });\n  }\n}\n\ndefineAspects(InsertOperation, [Aspect.RETRYABLE, Aspect.WRITE_OPERATION]);\ndefineAspects(InsertOneOperation, [Aspect.RETRYABLE, Aspect.WRITE_OPERATION]);\ndefineAspects(InsertManyOperation, [Aspect.WRITE_OPERATION]);\n"]},"metadata":{},"sourceType":"script"}