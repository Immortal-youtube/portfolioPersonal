{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decompress = exports.compress = exports.uncompressibleCommands = exports.Compressor = void 0;\n\nconst util_1 = require(\"util\");\n\nconst zlib = require(\"zlib\");\n\nconst constants_1 = require(\"../../constants\");\n\nconst deps_1 = require(\"../../deps\");\n\nconst error_1 = require(\"../../error\");\n/** @public */\n\n\nexports.Compressor = Object.freeze({\n  none: 0,\n  snappy: 1,\n  zlib: 2,\n  zstd: 3\n});\nexports.uncompressibleCommands = new Set([constants_1.LEGACY_HELLO_COMMAND, 'saslStart', 'saslContinue', 'getnonce', 'authenticate', 'createUser', 'updateUser', 'copydbSaslStart', 'copydbgetnonce', 'copydb']);\nconst ZSTD_COMPRESSION_LEVEL = 3;\nconst zlibInflate = (0, util_1.promisify)(zlib.inflate.bind(zlib));\nconst zlibDeflate = (0, util_1.promisify)(zlib.deflate.bind(zlib)); // Facilitate compressing a message using an agreed compressor\n\nasync function compress(options, dataToBeCompressed) {\n  const zlibOptions = {};\n\n  switch (options.agreedCompressor) {\n    case 'snappy':\n      if ('kModuleError' in deps_1.Snappy) {\n        throw deps_1.Snappy['kModuleError'];\n      }\n\n      return deps_1.Snappy.compress(dataToBeCompressed);\n\n    case 'zstd':\n      if ('kModuleError' in deps_1.ZStandard) {\n        throw deps_1.ZStandard['kModuleError'];\n      }\n\n      return deps_1.ZStandard.compress(dataToBeCompressed, ZSTD_COMPRESSION_LEVEL);\n\n    case 'zlib':\n      if (options.zlibCompressionLevel) {\n        zlibOptions.level = options.zlibCompressionLevel;\n      }\n\n      return zlibDeflate(dataToBeCompressed, zlibOptions);\n\n    default:\n      throw new error_1.MongoInvalidArgumentError(`Unknown compressor ${options.agreedCompressor} failed to compress`);\n  }\n}\n\nexports.compress = compress; // Decompress a message using the given compressor\n\nasync function decompress(compressorID, compressedData) {\n  if (compressorID !== exports.Compressor.snappy && compressorID !== exports.Compressor.zstd && compressorID !== exports.Compressor.zlib && compressorID !== exports.Compressor.none) {\n    throw new error_1.MongoDecompressionError(`Server sent message compressed using an unsupported compressor. (Received compressor ID ${compressorID})`);\n  }\n\n  switch (compressorID) {\n    case exports.Compressor.snappy:\n      if ('kModuleError' in deps_1.Snappy) {\n        throw deps_1.Snappy['kModuleError'];\n      }\n\n      return deps_1.Snappy.uncompress(compressedData, {\n        asBuffer: true\n      });\n\n    case exports.Compressor.zstd:\n      if ('kModuleError' in deps_1.ZStandard) {\n        throw deps_1.ZStandard['kModuleError'];\n      }\n\n      return deps_1.ZStandard.decompress(compressedData);\n\n    case exports.Compressor.zlib:\n      return zlibInflate(compressedData);\n\n    default:\n      return compressedData;\n  }\n}\n\nexports.decompress = decompress;","map":{"version":3,"mappings":";;;;;;;AAAA;;AACA;;AAEA;;AACA;;AACA;AAEA;;;AACaA,qBAAaC,MAAM,CAACC,MAAP,CAAc;EACtCC,IAAI,EAAE,CADgC;EAEtCC,MAAM,EAAE,CAF8B;EAGtCC,IAAI,EAAE,CAHgC;EAItCC,IAAI,EAAE;AAJgC,CAAd,CAAb;AAaAN,iCAAyB,IAAIO,GAAJ,CAAQ,CAC5CC,gCAD4C,EAE5C,WAF4C,EAG5C,cAH4C,EAI5C,UAJ4C,EAK5C,cAL4C,EAM5C,YAN4C,EAO5C,YAP4C,EAQ5C,iBAR4C,EAS5C,gBAT4C,EAU5C,QAV4C,CAAR,CAAzB;AAab,MAAMC,sBAAsB,GAAG,CAA/B;AAEA,MAAMC,WAAW,GAAG,sBAAUL,IAAI,CAACM,OAAL,CAAaC,IAAb,CAAkBP,IAAlB,CAAV,CAApB;AACA,MAAMQ,WAAW,GAAG,sBAAUR,IAAI,CAACS,OAAL,CAAaF,IAAb,CAAkBP,IAAlB,CAAV,CAApB,C,CAEA;;AACO,eAAeU,QAAf,CACLC,OADK,EAELC,kBAFK,EAEqB;EAE1B,MAAMC,WAAW,GAAG,EAApB;;EACA,QAAQF,OAAO,CAACG,gBAAhB;IACE,KAAK,QAAL;MACE,IAAI,kBAAkBC,aAAtB,EAA8B;QAC5B,MAAMA,cAAO,cAAP,CAAN;MACD;;MACD,OAAOA,cAAOL,QAAP,CAAgBE,kBAAhB,CAAP;;IAEF,KAAK,MAAL;MACE,IAAI,kBAAkBG,gBAAtB,EAAiC;QAC/B,MAAMA,iBAAU,cAAV,CAAN;MACD;;MACD,OAAOA,iBAAUL,QAAV,CAAmBE,kBAAnB,EAAuCR,sBAAvC,CAAP;;IAEF,KAAK,MAAL;MACE,IAAIO,OAAO,CAACK,oBAAZ,EAAkC;QAChCH,WAAW,CAACI,KAAZ,GAAoBN,OAAO,CAACK,oBAA5B;MACD;;MACD,OAAOR,WAAW,CAACI,kBAAD,EAAqBC,WAArB,CAAlB;;IAEF;MACE,MAAM,IAAIK,iCAAJ,CACJ,sBAAsBP,OAAO,CAACG,gBAAgB,qBAD1C,CAAN;EApBJ;AAwBD;;AA7BDnB,4B,CA+BA;;AACO,eAAewB,UAAf,CAA0BC,YAA1B,EAAgDC,cAAhD,EAAsE;EAC3E,IACED,YAAY,KAAKzB,mBAAWI,MAA5B,IACAqB,YAAY,KAAKzB,mBAAWM,IAD5B,IAEAmB,YAAY,KAAKzB,mBAAWK,IAF5B,IAGAoB,YAAY,KAAKzB,mBAAWG,IAJ9B,EAKE;IACA,MAAM,IAAIoB,+BAAJ,CACJ,2FAA2FE,YAAY,GADnG,CAAN;EAGD;;EAED,QAAQA,YAAR;IACE,KAAKzB,mBAAWI,MAAhB;MACE,IAAI,kBAAkBgB,aAAtB,EAA8B;QAC5B,MAAMA,cAAO,cAAP,CAAN;MACD;;MACD,OAAOA,cAAOO,UAAP,CAAkBD,cAAlB,EAAkC;QAAEE,QAAQ,EAAE;MAAZ,CAAlC,CAAP;;IAEF,KAAK5B,mBAAWM,IAAhB;MACE,IAAI,kBAAkBc,gBAAtB,EAAiC;QAC/B,MAAMA,iBAAU,cAAV,CAAN;MACD;;MACD,OAAOA,iBAAUI,UAAV,CAAqBE,cAArB,CAAP;;IAEF,KAAK1B,mBAAWK,IAAhB;MACE,OAAOK,WAAW,CAACgB,cAAD,CAAlB;;IAEF;MACE,OAAOA,cAAP;EAjBJ;AAmBD;;AA/BD1B","names":["exports","Object","freeze","none","snappy","zlib","zstd","Set","constants_1","ZSTD_COMPRESSION_LEVEL","zlibInflate","inflate","bind","zlibDeflate","deflate","compress","options","dataToBeCompressed","zlibOptions","agreedCompressor","deps_1","zlibCompressionLevel","level","error_1","decompress","compressorID","compressedData","uncompress","asBuffer"],"sources":["C:\\Users\\anshs\\OneDrive\\Documents\\Code\\WebDevelopement\\portfolioPersonal\\node_modules\\mongodb\\src\\cmap\\wire_protocol\\compression.ts"],"sourcesContent":["import { promisify } from 'util';\nimport * as zlib from 'zlib';\n\nimport { LEGACY_HELLO_COMMAND } from '../../constants';\nimport { Snappy, ZStandard } from '../../deps';\nimport { MongoDecompressionError, MongoInvalidArgumentError } from '../../error';\n\n/** @public */\nexport const Compressor = Object.freeze({\n  none: 0,\n  snappy: 1,\n  zlib: 2,\n  zstd: 3\n} as const);\n\n/** @public */\nexport type Compressor = typeof Compressor[CompressorName];\n\n/** @public */\nexport type CompressorName = keyof typeof Compressor;\n\nexport const uncompressibleCommands = new Set([\n  LEGACY_HELLO_COMMAND,\n  'saslStart',\n  'saslContinue',\n  'getnonce',\n  'authenticate',\n  'createUser',\n  'updateUser',\n  'copydbSaslStart',\n  'copydbgetnonce',\n  'copydb'\n]);\n\nconst ZSTD_COMPRESSION_LEVEL = 3;\n\nconst zlibInflate = promisify(zlib.inflate.bind(zlib));\nconst zlibDeflate = promisify(zlib.deflate.bind(zlib));\n\n// Facilitate compressing a message using an agreed compressor\nexport async function compress(\n  options: { zlibCompressionLevel: number; agreedCompressor: CompressorName },\n  dataToBeCompressed: Buffer\n): Promise<Buffer> {\n  const zlibOptions = {} as zlib.ZlibOptions;\n  switch (options.agreedCompressor) {\n    case 'snappy':\n      if ('kModuleError' in Snappy) {\n        throw Snappy['kModuleError'];\n      }\n      return Snappy.compress(dataToBeCompressed);\n\n    case 'zstd':\n      if ('kModuleError' in ZStandard) {\n        throw ZStandard['kModuleError'];\n      }\n      return ZStandard.compress(dataToBeCompressed, ZSTD_COMPRESSION_LEVEL);\n\n    case 'zlib':\n      if (options.zlibCompressionLevel) {\n        zlibOptions.level = options.zlibCompressionLevel;\n      }\n      return zlibDeflate(dataToBeCompressed, zlibOptions);\n\n    default:\n      throw new MongoInvalidArgumentError(\n        `Unknown compressor ${options.agreedCompressor} failed to compress`\n      );\n  }\n}\n\n// Decompress a message using the given compressor\nexport async function decompress(compressorID: number, compressedData: Buffer): Promise<Buffer> {\n  if (\n    compressorID !== Compressor.snappy &&\n    compressorID !== Compressor.zstd &&\n    compressorID !== Compressor.zlib &&\n    compressorID !== Compressor.none\n  ) {\n    throw new MongoDecompressionError(\n      `Server sent message compressed using an unsupported compressor. (Received compressor ID ${compressorID})`\n    );\n  }\n\n  switch (compressorID) {\n    case Compressor.snappy:\n      if ('kModuleError' in Snappy) {\n        throw Snappy['kModuleError'];\n      }\n      return Snappy.uncompress(compressedData, { asBuffer: true });\n\n    case Compressor.zstd:\n      if ('kModuleError' in ZStandard) {\n        throw ZStandard['kModuleError'];\n      }\n      return ZStandard.decompress(compressedData);\n\n    case Compressor.zlib:\n      return zlibInflate(compressedData);\n\n    default:\n      return compressedData;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}