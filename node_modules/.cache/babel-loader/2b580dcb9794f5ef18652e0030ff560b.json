{"ast":null,"code":"import { HttpRequest, HttpResponse } from \"@aws-sdk/protocol-http\";\nimport { isServerError, isThrottlingError, isTransientError } from \"@aws-sdk/service-error-classification\";\nimport { INVOCATION_ID_HEADER, REQUEST_HEADER } from \"@aws-sdk/util-retry\";\nimport { v4 } from \"uuid\";\nimport { asSdkError } from \"./util\";\nexport const retryMiddleware = options => (next, context) => async args => {\n  let retryStrategy = await options.retryStrategy();\n  const maxAttempts = await options.maxAttempts();\n\n  if (isRetryStrategyV2(retryStrategy)) {\n    retryStrategy = retryStrategy;\n    let retryToken = await retryStrategy.acquireInitialRetryToken(context[\"partition_id\"]);\n    let lastError = new Error();\n    let attempts = 0;\n    let totalRetryDelay = 0;\n    const {\n      request\n    } = args;\n\n    if (HttpRequest.isInstance(request)) {\n      request.headers[INVOCATION_ID_HEADER] = v4();\n    }\n\n    while (true) {\n      try {\n        if (HttpRequest.isInstance(request)) {\n          request.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;\n        }\n\n        const {\n          response,\n          output\n        } = await next(args);\n        retryStrategy.recordSuccess(retryToken);\n        output.$metadata.attempts = attempts + 1;\n        output.$metadata.totalRetryDelay = totalRetryDelay;\n        return {\n          response,\n          output\n        };\n      } catch (e) {\n        const retryErrorInfo = getRetyErrorInto(e);\n        lastError = asSdkError(e);\n\n        try {\n          retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);\n        } catch (refreshError) {\n          if (!lastError.$metadata) {\n            lastError.$metadata = {};\n          }\n\n          lastError.$metadata.attempts = attempts + 1;\n          lastError.$metadata.totalRetryDelay = totalRetryDelay;\n          throw lastError;\n        }\n\n        attempts = retryToken.getRetryCount();\n        const delay = retryToken.getRetryDelay();\n        totalRetryDelay += delay;\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n  } else {\n    retryStrategy = retryStrategy;\n    if (retryStrategy?.mode) context.userAgent = [...(context.userAgent || []), [\"cfg/retry-mode\", retryStrategy.mode]];\n    return retryStrategy.retry(next, args);\n  }\n};\n\nconst isRetryStrategyV2 = retryStrategy => typeof retryStrategy.acquireInitialRetryToken !== \"undefined\" && typeof retryStrategy.refreshRetryTokenForRetry !== \"undefined\" && typeof retryStrategy.recordSuccess !== \"undefined\";\n\nconst getRetyErrorInto = error => {\n  const errorInfo = {\n    errorType: getRetryErrorType(error)\n  };\n  const retryAfterHint = getRetryAfterHint(error.$response);\n\n  if (retryAfterHint) {\n    errorInfo.retryAfterHint = retryAfterHint;\n  }\n\n  return errorInfo;\n};\n\nconst getRetryErrorType = error => {\n  if (isThrottlingError(error)) return \"THROTTLING\";\n  if (isTransientError(error)) return \"TRANSIENT\";\n  if (isServerError(error)) return \"SERVER_ERROR\";\n  return \"CLIENT_ERROR\";\n};\n\nexport const retryMiddlewareOptions = {\n  name: \"retryMiddleware\",\n  tags: [\"RETRY\"],\n  step: \"finalizeRequest\",\n  priority: \"high\",\n  override: true\n};\nexport const getRetryPlugin = options => ({\n  applyToStack: clientStack => {\n    clientStack.add(retryMiddleware(options), retryMiddlewareOptions);\n  }\n});\nexport const getRetryAfterHint = response => {\n  if (!HttpResponse.isInstance(response)) return;\n  const retryAfterHeaderName = Object.keys(response.headers).find(key => key.toLowerCase() === \"retry-after\");\n  if (!retryAfterHeaderName) return;\n  const retryAfter = response.headers[retryAfterHeaderName];\n  const retryAfterSeconds = Number(retryAfter);\n  if (!Number.isNaN(retryAfterSeconds)) return new Date(retryAfterSeconds * 1000);\n  const retryAfterDate = new Date(retryAfter);\n  return retryAfterDate;\n};","map":{"version":3,"names":["HttpRequest","HttpResponse","isServerError","isThrottlingError","isTransientError","INVOCATION_ID_HEADER","REQUEST_HEADER","v4","asSdkError","retryMiddleware","options","next","context","args","retryStrategy","maxAttempts","isRetryStrategyV2","retryToken","acquireInitialRetryToken","lastError","Error","attempts","totalRetryDelay","request","isInstance","headers","response","output","recordSuccess","$metadata","e","retryErrorInfo","getRetyErrorInto","refreshRetryTokenForRetry","refreshError","getRetryCount","delay","getRetryDelay","Promise","resolve","setTimeout","mode","userAgent","retry","error","errorInfo","errorType","getRetryErrorType","retryAfterHint","getRetryAfterHint","$response","retryMiddlewareOptions","name","tags","step","priority","override","getRetryPlugin","applyToStack","clientStack","add","retryAfterHeaderName","Object","keys","find","key","toLowerCase","retryAfter","retryAfterSeconds","Number","isNaN","Date","retryAfterDate"],"sources":["C:/Users/anshs/OneDrive/Documents/Code/WebDevelopement/portfolioPersonal/node_modules/@aws-sdk/middleware-retry/dist-es/retryMiddleware.js"],"sourcesContent":["import { HttpRequest, HttpResponse } from \"@aws-sdk/protocol-http\";\nimport { isServerError, isThrottlingError, isTransientError } from \"@aws-sdk/service-error-classification\";\nimport { INVOCATION_ID_HEADER, REQUEST_HEADER } from \"@aws-sdk/util-retry\";\nimport { v4 } from \"uuid\";\nimport { asSdkError } from \"./util\";\nexport const retryMiddleware = (options) => (next, context) => async (args) => {\n    let retryStrategy = await options.retryStrategy();\n    const maxAttempts = await options.maxAttempts();\n    if (isRetryStrategyV2(retryStrategy)) {\n        retryStrategy = retryStrategy;\n        let retryToken = await retryStrategy.acquireInitialRetryToken(context[\"partition_id\"]);\n        let lastError = new Error();\n        let attempts = 0;\n        let totalRetryDelay = 0;\n        const { request } = args;\n        if (HttpRequest.isInstance(request)) {\n            request.headers[INVOCATION_ID_HEADER] = v4();\n        }\n        while (true) {\n            try {\n                if (HttpRequest.isInstance(request)) {\n                    request.headers[REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;\n                }\n                const { response, output } = await next(args);\n                retryStrategy.recordSuccess(retryToken);\n                output.$metadata.attempts = attempts + 1;\n                output.$metadata.totalRetryDelay = totalRetryDelay;\n                return { response, output };\n            }\n            catch (e) {\n                const retryErrorInfo = getRetyErrorInto(e);\n                lastError = asSdkError(e);\n                try {\n                    retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);\n                }\n                catch (refreshError) {\n                    if (!lastError.$metadata) {\n                        lastError.$metadata = {};\n                    }\n                    lastError.$metadata.attempts = attempts + 1;\n                    lastError.$metadata.totalRetryDelay = totalRetryDelay;\n                    throw lastError;\n                }\n                attempts = retryToken.getRetryCount();\n                const delay = retryToken.getRetryDelay();\n                totalRetryDelay += delay;\n                await new Promise((resolve) => setTimeout(resolve, delay));\n            }\n        }\n    }\n    else {\n        retryStrategy = retryStrategy;\n        if (retryStrategy?.mode)\n            context.userAgent = [...(context.userAgent || []), [\"cfg/retry-mode\", retryStrategy.mode]];\n        return retryStrategy.retry(next, args);\n    }\n};\nconst isRetryStrategyV2 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== \"undefined\" &&\n    typeof retryStrategy.refreshRetryTokenForRetry !== \"undefined\" &&\n    typeof retryStrategy.recordSuccess !== \"undefined\";\nconst getRetyErrorInto = (error) => {\n    const errorInfo = {\n        errorType: getRetryErrorType(error),\n    };\n    const retryAfterHint = getRetryAfterHint(error.$response);\n    if (retryAfterHint) {\n        errorInfo.retryAfterHint = retryAfterHint;\n    }\n    return errorInfo;\n};\nconst getRetryErrorType = (error) => {\n    if (isThrottlingError(error))\n        return \"THROTTLING\";\n    if (isTransientError(error))\n        return \"TRANSIENT\";\n    if (isServerError(error))\n        return \"SERVER_ERROR\";\n    return \"CLIENT_ERROR\";\n};\nexport const retryMiddlewareOptions = {\n    name: \"retryMiddleware\",\n    tags: [\"RETRY\"],\n    step: \"finalizeRequest\",\n    priority: \"high\",\n    override: true,\n};\nexport const getRetryPlugin = (options) => ({\n    applyToStack: (clientStack) => {\n        clientStack.add(retryMiddleware(options), retryMiddlewareOptions);\n    },\n});\nexport const getRetryAfterHint = (response) => {\n    if (!HttpResponse.isInstance(response))\n        return;\n    const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === \"retry-after\");\n    if (!retryAfterHeaderName)\n        return;\n    const retryAfter = response.headers[retryAfterHeaderName];\n    const retryAfterSeconds = Number(retryAfter);\n    if (!Number.isNaN(retryAfterSeconds))\n        return new Date(retryAfterSeconds * 1000);\n    const retryAfterDate = new Date(retryAfter);\n    return retryAfterDate;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}