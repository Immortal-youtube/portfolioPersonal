{"ast":null,"code":"import { DEFAULT_MAX_ATTEMPTS, RETRY_MODES } from \"./config\";\nimport { DEFAULT_RETRY_DELAY_BASE, INITIAL_RETRY_TOKENS } from \"./constants\";\nimport { getDefaultRetryToken } from \"./defaultRetryToken\";\nexport class StandardRetryStrategy {\n  constructor(maxAttemptsProvider) {\n    this.maxAttemptsProvider = maxAttemptsProvider;\n    this.mode = RETRY_MODES.STANDARD;\n    this.retryToken = getDefaultRetryToken(INITIAL_RETRY_TOKENS, DEFAULT_RETRY_DELAY_BASE);\n    this.maxAttemptsProvider = maxAttemptsProvider;\n  }\n\n  async acquireInitialRetryToken(retryTokenScope) {\n    return this.retryToken;\n  }\n\n  async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {\n    const maxAttempts = await this.getMaxAttempts();\n\n    if (this.shouldRetry(tokenToRenew, errorInfo, maxAttempts)) {\n      tokenToRenew.getRetryTokenCount(errorInfo);\n      return tokenToRenew;\n    }\n\n    throw new Error(\"No retry token available\");\n  }\n\n  recordSuccess(token) {\n    this.retryToken.releaseRetryTokens(token.getLastRetryCost());\n  }\n\n  async getMaxAttempts() {\n    let maxAttempts;\n\n    try {\n      return await this.maxAttemptsProvider();\n    } catch (error) {\n      console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);\n      return DEFAULT_MAX_ATTEMPTS;\n    }\n  }\n\n  shouldRetry(tokenToRenew, errorInfo, maxAttempts) {\n    const attempts = tokenToRenew.getRetryCount();\n    return attempts < maxAttempts && tokenToRenew.hasRetryTokens(errorInfo.errorType) && this.isRetryableError(errorInfo.errorType);\n  }\n\n  isRetryableError(errorType) {\n    return errorType === \"THROTTLING\" || errorType === \"TRANSIENT\";\n  }\n\n}","map":{"version":3,"names":["DEFAULT_MAX_ATTEMPTS","RETRY_MODES","DEFAULT_RETRY_DELAY_BASE","INITIAL_RETRY_TOKENS","getDefaultRetryToken","StandardRetryStrategy","constructor","maxAttemptsProvider","mode","STANDARD","retryToken","acquireInitialRetryToken","retryTokenScope","refreshRetryTokenForRetry","tokenToRenew","errorInfo","maxAttempts","getMaxAttempts","shouldRetry","getRetryTokenCount","Error","recordSuccess","token","releaseRetryTokens","getLastRetryCost","error","console","warn","attempts","getRetryCount","hasRetryTokens","errorType","isRetryableError"],"sources":["C:/Users/anshs/OneDrive/Documents/Code/WebDevelopement/portfolioPersonal/node_modules/@aws-sdk/util-retry/dist-es/StandardRetryStrategy.js"],"sourcesContent":["import { DEFAULT_MAX_ATTEMPTS, RETRY_MODES } from \"./config\";\nimport { DEFAULT_RETRY_DELAY_BASE, INITIAL_RETRY_TOKENS } from \"./constants\";\nimport { getDefaultRetryToken } from \"./defaultRetryToken\";\nexport class StandardRetryStrategy {\n    constructor(maxAttemptsProvider) {\n        this.maxAttemptsProvider = maxAttemptsProvider;\n        this.mode = RETRY_MODES.STANDARD;\n        this.retryToken = getDefaultRetryToken(INITIAL_RETRY_TOKENS, DEFAULT_RETRY_DELAY_BASE);\n        this.maxAttemptsProvider = maxAttemptsProvider;\n    }\n    async acquireInitialRetryToken(retryTokenScope) {\n        return this.retryToken;\n    }\n    async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {\n        const maxAttempts = await this.getMaxAttempts();\n        if (this.shouldRetry(tokenToRenew, errorInfo, maxAttempts)) {\n            tokenToRenew.getRetryTokenCount(errorInfo);\n            return tokenToRenew;\n        }\n        throw new Error(\"No retry token available\");\n    }\n    recordSuccess(token) {\n        this.retryToken.releaseRetryTokens(token.getLastRetryCost());\n    }\n    async getMaxAttempts() {\n        let maxAttempts;\n        try {\n            return await this.maxAttemptsProvider();\n        }\n        catch (error) {\n            console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);\n            return DEFAULT_MAX_ATTEMPTS;\n        }\n    }\n    shouldRetry(tokenToRenew, errorInfo, maxAttempts) {\n        const attempts = tokenToRenew.getRetryCount();\n        return (attempts < maxAttempts &&\n            tokenToRenew.hasRetryTokens(errorInfo.errorType) &&\n            this.isRetryableError(errorInfo.errorType));\n    }\n    isRetryableError(errorType) {\n        return errorType === \"THROTTLING\" || errorType === \"TRANSIENT\";\n    }\n}\n"],"mappings":"AAAA,SAASA,oBAAT,EAA+BC,WAA/B,QAAkD,UAAlD;AACA,SAASC,wBAAT,EAAmCC,oBAAnC,QAA+D,aAA/D;AACA,SAASC,oBAAT,QAAqC,qBAArC;AACA,OAAO,MAAMC,qBAAN,CAA4B;EAC/BC,WAAW,CAACC,mBAAD,EAAsB;IAC7B,KAAKA,mBAAL,GAA2BA,mBAA3B;IACA,KAAKC,IAAL,GAAYP,WAAW,CAACQ,QAAxB;IACA,KAAKC,UAAL,GAAkBN,oBAAoB,CAACD,oBAAD,EAAuBD,wBAAvB,CAAtC;IACA,KAAKK,mBAAL,GAA2BA,mBAA3B;EACH;;EAC6B,MAAxBI,wBAAwB,CAACC,eAAD,EAAkB;IAC5C,OAAO,KAAKF,UAAZ;EACH;;EAC8B,MAAzBG,yBAAyB,CAACC,YAAD,EAAeC,SAAf,EAA0B;IACrD,MAAMC,WAAW,GAAG,MAAM,KAAKC,cAAL,EAA1B;;IACA,IAAI,KAAKC,WAAL,CAAiBJ,YAAjB,EAA+BC,SAA/B,EAA0CC,WAA1C,CAAJ,EAA4D;MACxDF,YAAY,CAACK,kBAAb,CAAgCJ,SAAhC;MACA,OAAOD,YAAP;IACH;;IACD,MAAM,IAAIM,KAAJ,CAAU,0BAAV,CAAN;EACH;;EACDC,aAAa,CAACC,KAAD,EAAQ;IACjB,KAAKZ,UAAL,CAAgBa,kBAAhB,CAAmCD,KAAK,CAACE,gBAAN,EAAnC;EACH;;EACmB,MAAdP,cAAc,GAAG;IACnB,IAAID,WAAJ;;IACA,IAAI;MACA,OAAO,MAAM,KAAKT,mBAAL,EAAb;IACH,CAFD,CAGA,OAAOkB,KAAP,EAAc;MACVC,OAAO,CAACC,IAAR,CAAc,6DAA4D3B,oBAAqB,EAA/F;MACA,OAAOA,oBAAP;IACH;EACJ;;EACDkB,WAAW,CAACJ,YAAD,EAAeC,SAAf,EAA0BC,WAA1B,EAAuC;IAC9C,MAAMY,QAAQ,GAAGd,YAAY,CAACe,aAAb,EAAjB;IACA,OAAQD,QAAQ,GAAGZ,WAAX,IACJF,YAAY,CAACgB,cAAb,CAA4Bf,SAAS,CAACgB,SAAtC,CADI,IAEJ,KAAKC,gBAAL,CAAsBjB,SAAS,CAACgB,SAAhC,CAFJ;EAGH;;EACDC,gBAAgB,CAACD,SAAD,EAAY;IACxB,OAAOA,SAAS,KAAK,YAAd,IAA8BA,SAAS,KAAK,WAAnD;EACH;;AAvC8B"},"metadata":{},"sourceType":"module"}