{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseUnsignedInteger = exports.parseInteger = exports.compareObjectId = exports.getMongoDBClientEncryption = exports.commandSupportsReadConcern = exports.shuffle = exports.supportsRetryableWrites = exports.enumToString = exports.emitWarningOnce = exports.emitWarning = exports.MONGODB_WARNING_CODE = exports.DEFAULT_PK_FACTORY = exports.HostAddress = exports.BufferPool = exports.List = exports.deepCopy = exports.isRecord = exports.setDifference = exports.isHello = exports.isSuperset = exports.resolveOptions = exports.hasAtomicOperators = exports.calculateDurationInMs = exports.now = exports.makeClientMetadata = exports.makeStateMachine = exports.errorStrictEqual = exports.arrayStrictEqual = exports.eachAsyncSeries = exports.eachAsync = exports.maxWireVersion = exports.uuidV4 = exports.databaseNamespace = exports.maybeCallback = exports.makeCounter = exports.MongoDBNamespace = exports.ns = exports.getTopology = exports.decorateWithExplain = exports.decorateWithReadConcern = exports.decorateWithCollation = exports.isPromiseLike = exports.applyWriteConcern = exports.applyRetryableWrites = exports.filterOptions = exports.mergeOptions = exports.isObject = exports.normalizeHintField = exports.checkCollectionName = exports.ByteUtils = void 0;\n\nconst crypto = require(\"crypto\");\n\nconst os = require(\"os\");\n\nconst url_1 = require(\"url\");\n\nconst bson_1 = require(\"./bson\");\n\nconst constants_1 = require(\"./cmap/wire_protocol/constants\");\n\nconst constants_2 = require(\"./constants\");\n\nconst error_1 = require(\"./error\");\n\nconst read_concern_1 = require(\"./read_concern\");\n\nconst read_preference_1 = require(\"./read_preference\");\n\nconst common_1 = require(\"./sdam/common\");\n\nconst write_concern_1 = require(\"./write_concern\");\n\nexports.ByteUtils = {\n  toLocalBufferType(buffer) {\n    return Buffer.isBuffer(buffer) ? buffer : Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  },\n\n  equals(seqA, seqB) {\n    return exports.ByteUtils.toLocalBufferType(seqA).equals(seqB);\n  },\n\n  compare(seqA, seqB) {\n    return exports.ByteUtils.toLocalBufferType(seqA).compare(seqB);\n  },\n\n  toBase64(uint8array) {\n    return exports.ByteUtils.toLocalBufferType(uint8array).toString('base64');\n  }\n\n};\n/**\n * Throws if collectionName is not a valid mongodb collection namespace.\n * @internal\n */\n\nfunction checkCollectionName(collectionName) {\n  if ('string' !== typeof collectionName) {\n    throw new error_1.MongoInvalidArgumentError('Collection name must be a String');\n  }\n\n  if (!collectionName || collectionName.indexOf('..') !== -1) {\n    throw new error_1.MongoInvalidArgumentError('Collection names cannot be empty');\n  }\n\n  if (collectionName.indexOf('$') !== -1 && collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new error_1.MongoInvalidArgumentError(\"Collection names must not contain '$'\");\n  }\n\n  if (collectionName.match(/^\\.|\\.$/) != null) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new error_1.MongoInvalidArgumentError(\"Collection names must not start or end with '.'\");\n  } // Validate that we are not passing 0x00 in the collection name\n\n\n  if (collectionName.indexOf('\\x00') !== -1) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new error_1.MongoInvalidArgumentError('Collection names cannot contain a null character');\n  }\n}\n\nexports.checkCollectionName = checkCollectionName;\n/**\n * Ensure Hint field is in a shape we expect:\n * - object of index names mapping to 1 or -1\n * - just an index name\n * @internal\n */\n\nfunction normalizeHintField(hint) {\n  let finalHint = undefined;\n\n  if (typeof hint === 'string') {\n    finalHint = hint;\n  } else if (Array.isArray(hint)) {\n    finalHint = {};\n    hint.forEach(param => {\n      finalHint[param] = 1;\n    });\n  } else if (hint != null && typeof hint === 'object') {\n    finalHint = {};\n\n    for (const name in hint) {\n      finalHint[name] = hint[name];\n    }\n  }\n\n  return finalHint;\n}\n\nexports.normalizeHintField = normalizeHintField;\n\nconst TO_STRING = object => Object.prototype.toString.call(object);\n/**\n * Checks if arg is an Object:\n * - **NOTE**: the check is based on the `[Symbol.toStringTag]() === 'Object'`\n * @internal\n */\n\n\nfunction isObject(arg) {\n  return '[object Object]' === TO_STRING(arg);\n}\n\nexports.isObject = isObject;\n/** @internal */\n\nfunction mergeOptions(target, source) {\n  return { ...target,\n    ...source\n  };\n}\n\nexports.mergeOptions = mergeOptions;\n/** @internal */\n\nfunction filterOptions(options, names) {\n  const filterOptions = {};\n\n  for (const name in options) {\n    if (names.includes(name)) {\n      filterOptions[name] = options[name];\n    }\n  } // Filtered options\n\n\n  return filterOptions;\n}\n\nexports.filterOptions = filterOptions;\n/**\n * Applies retryWrites: true to a command if retryWrites is set on the command's database.\n * @internal\n *\n * @param target - The target command to which we will apply retryWrites.\n * @param db - The database from which we can inherit a retryWrites value.\n */\n\nfunction applyRetryableWrites(target, db) {\n  if (db && db.s.options?.retryWrites) {\n    target.retryWrites = true;\n  }\n\n  return target;\n}\n\nexports.applyRetryableWrites = applyRetryableWrites;\n/**\n * Applies a write concern to a command based on well defined inheritance rules, optionally\n * detecting support for the write concern in the first place.\n * @internal\n *\n * @param target - the target command we will be applying the write concern to\n * @param sources - sources where we can inherit default write concerns from\n * @param options - optional settings passed into a command for write concern overrides\n */\n\nfunction applyWriteConcern(target, sources, options) {\n  options = options ?? {};\n  const db = sources.db;\n  const coll = sources.collection;\n\n  if (options.session && options.session.inTransaction()) {\n    // writeConcern is not allowed within a multi-statement transaction\n    if (target.writeConcern) {\n      delete target.writeConcern;\n    }\n\n    return target;\n  }\n\n  const writeConcern = write_concern_1.WriteConcern.fromOptions(options);\n\n  if (writeConcern) {\n    return Object.assign(target, {\n      writeConcern\n    });\n  }\n\n  if (coll && coll.writeConcern) {\n    return Object.assign(target, {\n      writeConcern: Object.assign({}, coll.writeConcern)\n    });\n  }\n\n  if (db && db.writeConcern) {\n    return Object.assign(target, {\n      writeConcern: Object.assign({}, db.writeConcern)\n    });\n  }\n\n  return target;\n}\n\nexports.applyWriteConcern = applyWriteConcern;\n/**\n * Checks if a given value is a Promise\n *\n * @typeParam T - The resolution type of the possible promise\n * @param value - An object that could be a promise\n * @returns true if the provided value is a Promise\n */\n\nfunction isPromiseLike(value) {\n  return !!value && typeof value.then === 'function';\n}\n\nexports.isPromiseLike = isPromiseLike;\n/**\n * Applies collation to a given command.\n * @internal\n *\n * @param command - the command on which to apply collation\n * @param target - target of command\n * @param options - options containing collation settings\n */\n\nfunction decorateWithCollation(command, target, options) {\n  const capabilities = getTopology(target).capabilities;\n\n  if (options.collation && typeof options.collation === 'object') {\n    if (capabilities && capabilities.commandsTakeCollation) {\n      command.collation = options.collation;\n    } else {\n      throw new error_1.MongoCompatibilityError(`Current topology does not support collation`);\n    }\n  }\n}\n\nexports.decorateWithCollation = decorateWithCollation;\n/**\n * Applies a read concern to a given command.\n * @internal\n *\n * @param command - the command on which to apply the read concern\n * @param coll - the parent collection of the operation calling this method\n */\n\nfunction decorateWithReadConcern(command, coll, options) {\n  if (options && options.session && options.session.inTransaction()) {\n    return;\n  }\n\n  const readConcern = Object.assign({}, command.readConcern || {});\n\n  if (coll.s.readConcern) {\n    Object.assign(readConcern, coll.s.readConcern);\n  }\n\n  if (Object.keys(readConcern).length > 0) {\n    Object.assign(command, {\n      readConcern: readConcern\n    });\n  }\n}\n\nexports.decorateWithReadConcern = decorateWithReadConcern;\n/**\n * Applies an explain to a given command.\n * @internal\n *\n * @param command - the command on which to apply the explain\n * @param options - the options containing the explain verbosity\n */\n\nfunction decorateWithExplain(command, explain) {\n  if (command.explain) {\n    return command;\n  }\n\n  return {\n    explain: command,\n    verbosity: explain.verbosity\n  };\n}\n\nexports.decorateWithExplain = decorateWithExplain;\n/**\n * A helper function to get the topology from a given provider. Throws\n * if the topology cannot be found.\n * @throws MongoNotConnectedError\n * @internal\n */\n\nfunction getTopology(provider) {\n  // MongoClient or ClientSession or AbstractCursor\n  if ('topology' in provider && provider.topology) {\n    return provider.topology;\n  } else if ('s' in provider && 'client' in provider.s && provider.s.client.topology) {\n    return provider.s.client.topology;\n  } else if ('s' in provider && 'db' in provider.s && provider.s.db.s.client.topology) {\n    return provider.s.db.s.client.topology;\n  }\n\n  throw new error_1.MongoNotConnectedError('MongoClient must be connected to perform this operation');\n}\n\nexports.getTopology = getTopology;\n/** @internal */\n\nfunction ns(ns) {\n  return MongoDBNamespace.fromString(ns);\n}\n\nexports.ns = ns;\n/** @public */\n\nclass MongoDBNamespace {\n  /**\n   * Create a namespace object\n   *\n   * @param db - database name\n   * @param collection - collection name\n   */\n  constructor(db, collection) {\n    this.db = db;\n    this.collection = collection === '' ? undefined : collection;\n  }\n\n  toString() {\n    return this.collection ? `${this.db}.${this.collection}` : this.db;\n  }\n\n  withCollection(collection) {\n    return new MongoDBNamespace(this.db, collection);\n  }\n\n  static fromString(namespace) {\n    if (typeof namespace !== 'string' || namespace === '') {\n      // TODO(NODE-3483): Replace with MongoNamespaceError\n      throw new error_1.MongoRuntimeError(`Cannot parse namespace from \"${namespace}\"`);\n    }\n\n    const [db, ...collectionParts] = namespace.split('.');\n    const collection = collectionParts.join('.');\n    return new MongoDBNamespace(db, collection === '' ? undefined : collection);\n  }\n\n}\n\nexports.MongoDBNamespace = MongoDBNamespace;\n/** @internal */\n\nfunction* makeCounter() {\n  let seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  let count = seed;\n\n  while (true) {\n    const newCount = count;\n    count += 1;\n    yield newCount;\n  }\n}\n\nexports.makeCounter = makeCounter;\n\nfunction maybeCallback(promiseFn, callback) {\n  const promise = promiseFn();\n\n  if (callback == null) {\n    return promise;\n  }\n\n  promise.then(result => callback(undefined, result), error => callback(error));\n  return;\n}\n\nexports.maybeCallback = maybeCallback;\n/** @internal */\n\nfunction databaseNamespace(ns) {\n  return ns.split('.')[0];\n}\n\nexports.databaseNamespace = databaseNamespace;\n/**\n * Synchronously Generate a UUIDv4\n * @internal\n */\n\nfunction uuidV4() {\n  const result = crypto.randomBytes(16);\n  result[6] = result[6] & 0x0f | 0x40;\n  result[8] = result[8] & 0x3f | 0x80;\n  return result;\n}\n\nexports.uuidV4 = uuidV4;\n/**\n * A helper function for determining `maxWireVersion` between legacy and new topology instances\n * @internal\n */\n\nfunction maxWireVersion(topologyOrServer) {\n  if (topologyOrServer) {\n    if (topologyOrServer.loadBalanced) {\n      // Since we do not have a monitor, we assume the load balanced server is always\n      // pointed at the latest mongodb version. There is a risk that for on-prem\n      // deployments that don't upgrade immediately that this could alert to the\n      // application that a feature is available that is actually not.\n      return constants_1.MAX_SUPPORTED_WIRE_VERSION;\n    }\n\n    if (topologyOrServer.hello) {\n      return topologyOrServer.hello.maxWireVersion;\n    }\n\n    if ('lastHello' in topologyOrServer && typeof topologyOrServer.lastHello === 'function') {\n      const lastHello = topologyOrServer.lastHello();\n\n      if (lastHello) {\n        return lastHello.maxWireVersion;\n      }\n    }\n\n    if (topologyOrServer.description && 'maxWireVersion' in topologyOrServer.description && topologyOrServer.description.maxWireVersion != null) {\n      return topologyOrServer.description.maxWireVersion;\n    }\n  }\n\n  return 0;\n}\n\nexports.maxWireVersion = maxWireVersion;\n/**\n * Applies the function `eachFn` to each item in `arr`, in parallel.\n * @internal\n *\n * @param arr - An array of items to asynchronously iterate over\n * @param eachFn - A function to call on each item of the array. The callback signature is `(item, callback)`, where the callback indicates iteration is complete.\n * @param callback - The callback called after every item has been iterated\n */\n\nfunction eachAsync(arr, eachFn, callback) {\n  arr = arr || [];\n  let idx = 0;\n  let awaiting = 0;\n\n  for (idx = 0; idx < arr.length; ++idx) {\n    awaiting++;\n    eachFn(arr[idx], eachCallback);\n  }\n\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n\n  function eachCallback(err) {\n    awaiting--;\n\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n    }\n  }\n}\n\nexports.eachAsync = eachAsync;\n/** @internal */\n\nfunction eachAsyncSeries(arr, eachFn, callback) {\n  arr = arr || [];\n  let idx = 0;\n  let awaiting = arr.length;\n\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n\n  function eachCallback(err) {\n    idx++;\n    awaiting--;\n\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n      return;\n    }\n\n    eachFn(arr[idx], eachCallback);\n  }\n\n  eachFn(arr[idx], eachCallback);\n}\n\nexports.eachAsyncSeries = eachAsyncSeries;\n/** @internal */\n\nfunction arrayStrictEqual(arr, arr2) {\n  if (!Array.isArray(arr) || !Array.isArray(arr2)) {\n    return false;\n  }\n\n  return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);\n}\n\nexports.arrayStrictEqual = arrayStrictEqual;\n/** @internal */\n\nfunction errorStrictEqual(lhs, rhs) {\n  if (lhs === rhs) {\n    return true;\n  }\n\n  if (!lhs || !rhs) {\n    return lhs === rhs;\n  }\n\n  if (lhs == null && rhs != null || lhs != null && rhs == null) {\n    return false;\n  }\n\n  if (lhs.constructor.name !== rhs.constructor.name) {\n    return false;\n  }\n\n  if (lhs.message !== rhs.message) {\n    return false;\n  }\n\n  return true;\n}\n\nexports.errorStrictEqual = errorStrictEqual;\n/** @internal */\n\nfunction makeStateMachine(stateTable) {\n  return function stateTransition(target, newState) {\n    const legalStates = stateTable[target.s.state];\n\n    if (legalStates && legalStates.indexOf(newState) < 0) {\n      throw new error_1.MongoRuntimeError(`illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`);\n    }\n\n    target.emit('stateChanged', target.s.state, newState);\n    target.s.state = newState;\n  };\n}\n\nexports.makeStateMachine = makeStateMachine; // eslint-disable-next-line @typescript-eslint/no-var-requires\n\nconst NODE_DRIVER_VERSION = require('../package.json').version;\n\nfunction makeClientMetadata(options) {\n  options = options ?? {};\n  const metadata = {\n    driver: {\n      name: 'nodejs',\n      version: NODE_DRIVER_VERSION\n    },\n    os: {\n      type: os.type(),\n      name: process.platform,\n      architecture: process.arch,\n      version: os.release()\n    },\n    platform: `Node.js ${process.version}, ${os.endianness()} (unified)`\n  }; // support optionally provided wrapping driver info\n\n  if (options.driverInfo) {\n    if (options.driverInfo.name) {\n      metadata.driver.name = `${metadata.driver.name}|${options.driverInfo.name}`;\n    }\n\n    if (options.driverInfo.version) {\n      metadata.version = `${metadata.driver.version}|${options.driverInfo.version}`;\n    }\n\n    if (options.driverInfo.platform) {\n      metadata.platform = `${metadata.platform}|${options.driverInfo.platform}`;\n    }\n  }\n\n  if (options.appName) {\n    // MongoDB requires the appName not exceed a byte length of 128\n    const buffer = Buffer.from(options.appName);\n    metadata.application = {\n      name: buffer.byteLength > 128 ? buffer.slice(0, 128).toString('utf8') : options.appName\n    };\n  }\n\n  return metadata;\n}\n\nexports.makeClientMetadata = makeClientMetadata;\n/** @internal */\n\nfunction now() {\n  const hrtime = process.hrtime();\n  return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);\n}\n\nexports.now = now;\n/** @internal */\n\nfunction calculateDurationInMs(started) {\n  if (typeof started !== 'number') {\n    throw new error_1.MongoInvalidArgumentError('Numeric value required to calculate duration');\n  }\n\n  const elapsed = now() - started;\n  return elapsed < 0 ? 0 : elapsed;\n}\n\nexports.calculateDurationInMs = calculateDurationInMs;\n/** @internal */\n\nfunction hasAtomicOperators(doc) {\n  if (Array.isArray(doc)) {\n    for (const document of doc) {\n      if (hasAtomicOperators(document)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  const keys = Object.keys(doc);\n  return keys.length > 0 && keys[0][0] === '$';\n}\n\nexports.hasAtomicOperators = hasAtomicOperators;\n/**\n * Merge inherited properties from parent into options, prioritizing values from options,\n * then values from parent.\n * @internal\n */\n\nfunction resolveOptions(parent, options) {\n  const result = Object.assign({}, options, (0, bson_1.resolveBSONOptions)(options, parent)); // Users cannot pass a readConcern/writeConcern to operations in a transaction\n\n  const session = options?.session;\n\n  if (!session?.inTransaction()) {\n    const readConcern = read_concern_1.ReadConcern.fromOptions(options) ?? parent?.readConcern;\n\n    if (readConcern) {\n      result.readConcern = readConcern;\n    }\n\n    const writeConcern = write_concern_1.WriteConcern.fromOptions(options) ?? parent?.writeConcern;\n\n    if (writeConcern) {\n      result.writeConcern = writeConcern;\n    }\n  }\n\n  const readPreference = read_preference_1.ReadPreference.fromOptions(options) ?? parent?.readPreference;\n\n  if (readPreference) {\n    result.readPreference = readPreference;\n  }\n\n  return result;\n}\n\nexports.resolveOptions = resolveOptions;\n\nfunction isSuperset(set, subset) {\n  set = Array.isArray(set) ? new Set(set) : set;\n  subset = Array.isArray(subset) ? new Set(subset) : subset;\n\n  for (const elem of subset) {\n    if (!set.has(elem)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.isSuperset = isSuperset;\n/**\n * Checks if the document is a Hello request\n * @internal\n */\n\nfunction isHello(doc) {\n  return doc[constants_2.LEGACY_HELLO_COMMAND] || doc.hello ? true : false;\n}\n\nexports.isHello = isHello;\n/** Returns the items that are uniquely in setA */\n\nfunction setDifference(setA, setB) {\n  const difference = new Set(setA);\n\n  for (const elem of setB) {\n    difference.delete(elem);\n  }\n\n  return difference;\n}\n\nexports.setDifference = setDifference;\n\nconst HAS_OWN = (object, prop) => Object.prototype.hasOwnProperty.call(object, prop);\n\nfunction isRecord(value) {\n  let requiredKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n  if (!isObject(value)) {\n    return false;\n  }\n\n  const ctor = value.constructor;\n\n  if (ctor && ctor.prototype) {\n    if (!isObject(ctor.prototype)) {\n      return false;\n    } // Check to see if some method exists from the Object exists\n\n\n    if (!HAS_OWN(ctor.prototype, 'isPrototypeOf')) {\n      return false;\n    }\n  }\n\n  if (requiredKeys) {\n    const keys = Object.keys(value);\n    return isSuperset(keys, requiredKeys);\n  }\n\n  return true;\n}\n\nexports.isRecord = isRecord;\n/**\n * Make a deep copy of an object\n *\n * NOTE: This is not meant to be the perfect implementation of a deep copy,\n * but instead something that is good enough for the purposes of\n * command monitoring.\n */\n\nfunction deepCopy(value) {\n  if (value == null) {\n    return value;\n  } else if (Array.isArray(value)) {\n    return value.map(item => deepCopy(item));\n  } else if (isRecord(value)) {\n    const res = {};\n\n    for (const key in value) {\n      res[key] = deepCopy(value[key]);\n    }\n\n    return res;\n  }\n\n  const ctor = value.constructor;\n\n  if (ctor) {\n    switch (ctor.name.toLowerCase()) {\n      case 'date':\n        return new ctor(Number(value));\n\n      case 'map':\n        return new Map(value);\n\n      case 'set':\n        return new Set(value);\n\n      case 'buffer':\n        return Buffer.from(value);\n    }\n  }\n\n  return value;\n}\n\nexports.deepCopy = deepCopy;\n/**\n * A sequential list of items in a circularly linked list\n * @remarks\n * The head node is special, it is always defined and has a value of null.\n * It is never \"included\" in the list, in that, it is not returned by pop/shift or yielded by the iterator.\n * The circular linkage and always defined head node are to reduce checks for null next/prev references to zero.\n * New nodes are declared as object literals with keys always in the same order: next, prev, value.\n * @internal\n */\n\nclass List {\n  get length() {\n    return this.count;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'List';\n  }\n\n  constructor() {\n    this.count = 0; // this is carefully crafted:\n    // declaring a complete and consistently key ordered\n    // object is beneficial to the runtime optimizations\n\n    this.head = {\n      next: null,\n      prev: null,\n      value: null\n    };\n    this.head.next = this.head;\n    this.head.prev = this.head;\n  }\n\n  toArray() {\n    return Array.from(this);\n  }\n\n  toString() {\n    return `head <=> ${this.toArray().join(' <=> ')} <=> head`;\n  }\n\n  *[Symbol.iterator]() {\n    for (const node of this.nodes()) {\n      yield node.value;\n    }\n  }\n\n  *nodes() {\n    let ptr = this.head.next;\n\n    while (ptr !== this.head) {\n      // Save next before yielding so that we make removing within iteration safe\n      const {\n        next\n      } = ptr;\n      yield ptr;\n      ptr = next;\n    }\n  }\n  /** Insert at end of list */\n\n\n  push(value) {\n    this.count += 1;\n    const newNode = {\n      next: this.head,\n      prev: this.head.prev,\n      value\n    };\n    this.head.prev.next = newNode;\n    this.head.prev = newNode;\n  }\n  /** Inserts every item inside an iterable instead of the iterable itself */\n\n\n  pushMany(iterable) {\n    for (const value of iterable) {\n      this.push(value);\n    }\n  }\n  /** Insert at front of list */\n\n\n  unshift(value) {\n    this.count += 1;\n    const newNode = {\n      next: this.head.next,\n      prev: this.head,\n      value\n    };\n    this.head.next.prev = newNode;\n    this.head.next = newNode;\n  }\n\n  remove(node) {\n    if (node === this.head || this.length === 0) {\n      return null;\n    }\n\n    this.count -= 1;\n    const prevNode = node.prev;\n    const nextNode = node.next;\n    prevNode.next = nextNode;\n    nextNode.prev = prevNode;\n    return node.value;\n  }\n  /** Removes the first node at the front of the list */\n\n\n  shift() {\n    return this.remove(this.head.next);\n  }\n  /** Removes the last node at the end of the list */\n\n\n  pop() {\n    return this.remove(this.head.prev);\n  }\n  /** Iterates through the list and removes nodes where filter returns true */\n\n\n  prune(filter) {\n    for (const node of this.nodes()) {\n      if (filter(node.value)) {\n        this.remove(node);\n      }\n    }\n  }\n\n  clear() {\n    this.count = 0;\n    this.head.next = this.head;\n    this.head.prev = this.head;\n  }\n  /** Returns the first item in the list, does not remove */\n\n\n  first() {\n    // If the list is empty, value will be the head's null\n    return this.head.next.value;\n  }\n  /** Returns the last item in the list, does not remove */\n\n\n  last() {\n    // If the list is empty, value will be the head's null\n    return this.head.prev.value;\n  }\n\n}\n\nexports.List = List;\n/**\n * A pool of Buffers which allow you to read them as if they were one\n * @internal\n */\n\nclass BufferPool {\n  constructor() {\n    this.buffers = new List();\n    this.totalByteLength = 0;\n  }\n\n  get length() {\n    return this.totalByteLength;\n  }\n  /** Adds a buffer to the internal buffer pool list */\n\n\n  append(buffer) {\n    this.buffers.push(buffer);\n    this.totalByteLength += buffer.length;\n  }\n  /**\n   * If BufferPool contains 4 bytes or more construct an int32 from the leading bytes,\n   * otherwise return null. Size can be negative, caller should error check.\n   */\n\n\n  getInt32() {\n    if (this.totalByteLength < 4) {\n      return null;\n    }\n\n    const firstBuffer = this.buffers.first();\n\n    if (firstBuffer != null && firstBuffer.byteLength >= 4) {\n      return firstBuffer.readInt32LE(0);\n    } // Unlikely case: an int32 is split across buffers.\n    // Use read and put the returned buffer back on top\n\n\n    const top4Bytes = this.read(4);\n    const value = top4Bytes.readInt32LE(0); // Put it back.\n\n    this.totalByteLength += 4;\n    this.buffers.unshift(top4Bytes);\n    return value;\n  }\n  /** Reads the requested number of bytes, optionally consuming them */\n\n\n  read(size) {\n    if (typeof size !== 'number' || size < 0) {\n      throw new error_1.MongoInvalidArgumentError('Argument \"size\" must be a non-negative number');\n    } // oversized request returns empty buffer\n\n\n    if (size > this.totalByteLength) {\n      return Buffer.alloc(0);\n    } // We know we have enough, we just don't know how it is spread across chunks\n    // TODO(NODE-4732): alloc API should change based on raw option\n\n\n    const result = Buffer.allocUnsafe(size);\n\n    for (let bytesRead = 0; bytesRead < size;) {\n      const buffer = this.buffers.shift();\n\n      if (buffer == null) {\n        break;\n      }\n\n      const bytesRemaining = size - bytesRead;\n      const bytesReadable = Math.min(bytesRemaining, buffer.byteLength);\n      const bytes = buffer.subarray(0, bytesReadable);\n      result.set(bytes, bytesRead);\n      bytesRead += bytesReadable;\n      this.totalByteLength -= bytesReadable;\n\n      if (bytesReadable < buffer.byteLength) {\n        this.buffers.unshift(buffer.subarray(bytesReadable));\n      }\n    }\n\n    return result;\n  }\n\n}\n\nexports.BufferPool = BufferPool;\n/** @public */\n\nclass HostAddress {\n  constructor(hostString) {\n    this.host = undefined;\n    this.port = undefined;\n    this.socketPath = undefined;\n    this.isIPv6 = false;\n    const escapedHost = hostString.split(' ').join('%20'); // escape spaces, for socket path hosts\n\n    if (escapedHost.endsWith('.sock')) {\n      // heuristically determine if we're working with a domain socket\n      this.socketPath = decodeURIComponent(escapedHost);\n      return;\n    }\n\n    const urlString = `iLoveJS://${escapedHost}`;\n    let url;\n\n    try {\n      url = new url_1.URL(urlString);\n    } catch (urlError) {\n      const runtimeError = new error_1.MongoRuntimeError(`Unable to parse ${escapedHost} with URL`);\n      runtimeError.cause = urlError;\n      throw runtimeError;\n    }\n\n    const hostname = url.hostname;\n    const port = url.port;\n    let normalized = decodeURIComponent(hostname).toLowerCase();\n\n    if (normalized.startsWith('[') && normalized.endsWith(']')) {\n      this.isIPv6 = true;\n      normalized = normalized.substring(1, hostname.length - 1);\n    }\n\n    this.host = normalized.toLowerCase();\n\n    if (typeof port === 'number') {\n      this.port = port;\n    } else if (typeof port === 'string' && port !== '') {\n      this.port = Number.parseInt(port, 10);\n    } else {\n      this.port = 27017;\n    }\n\n    if (this.port === 0) {\n      throw new error_1.MongoParseError('Invalid port (zero) with hostname');\n    }\n\n    Object.freeze(this);\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return this.inspect();\n  }\n\n  inspect() {\n    return `new HostAddress('${this.toString()}')`;\n  }\n\n  toString() {\n    if (typeof this.host === 'string') {\n      if (this.isIPv6) {\n        return `[${this.host}]:${this.port}`;\n      }\n\n      return `${this.host}:${this.port}`;\n    }\n\n    return `${this.socketPath}`;\n  }\n\n  static fromString(s) {\n    return new HostAddress(s);\n  }\n\n  static fromHostPort(host, port) {\n    if (host.includes(':')) {\n      host = `[${host}]`; // IPv6 address\n    }\n\n    return HostAddress.fromString(`${host}:${port}`);\n  }\n\n  static fromSrvRecord(_ref) {\n    let {\n      name,\n      port\n    } = _ref;\n    return HostAddress.fromHostPort(name, port);\n  }\n\n}\n\nexports.HostAddress = HostAddress;\nexports.DEFAULT_PK_FACTORY = {\n  // We prefer not to rely on ObjectId having a createPk method\n  createPk() {\n    return new bson_1.ObjectId();\n  }\n\n};\n/**\n * When the driver used emitWarning the code will be equal to this.\n * @public\n *\n * @example\n * ```ts\n * process.on('warning', (warning) => {\n *  if (warning.code === MONGODB_WARNING_CODE) console.error('Ah an important warning! :)')\n * })\n * ```\n */\n\nexports.MONGODB_WARNING_CODE = 'MONGODB DRIVER';\n/** @internal */\n\nfunction emitWarning(message) {\n  return process.emitWarning(message, {\n    code: exports.MONGODB_WARNING_CODE\n  });\n}\n\nexports.emitWarning = emitWarning;\nconst emittedWarnings = new Set();\n/**\n * Will emit a warning once for the duration of the application.\n * Uses the message to identify if it has already been emitted\n * so using string interpolation can cause multiple emits\n * @internal\n */\n\nfunction emitWarningOnce(message) {\n  if (!emittedWarnings.has(message)) {\n    emittedWarnings.add(message);\n    return emitWarning(message);\n  }\n}\n\nexports.emitWarningOnce = emitWarningOnce;\n/**\n * Takes a JS object and joins the values into a string separated by ', '\n */\n\nfunction enumToString(en) {\n  return Object.values(en).join(', ');\n}\n\nexports.enumToString = enumToString;\n/**\n * Determine if a server supports retryable writes.\n *\n * @internal\n */\n\nfunction supportsRetryableWrites(server) {\n  if (!server) {\n    return false;\n  }\n\n  if (server.loadBalanced) {\n    // Loadbalanced topologies will always support retry writes\n    return true;\n  }\n\n  if (server.description.logicalSessionTimeoutMinutes != null) {\n    // that supports sessions\n    if (server.description.type !== common_1.ServerType.Standalone) {\n      // and that is not a standalone\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexports.supportsRetryableWrites = supportsRetryableWrites;\n/**\n * Fisher–Yates Shuffle\n *\n * Reference: https://bost.ocks.org/mike/shuffle/\n * @param sequence - items to be shuffled\n * @param limit - Defaults to `0`. If nonzero shuffle will slice the randomized array e.g, `.slice(0, limit)` otherwise will return the entire randomized array.\n */\n\nfunction shuffle(sequence) {\n  let limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const items = Array.from(sequence); // shallow copy in order to never shuffle the input\n\n  if (limit > items.length) {\n    throw new error_1.MongoRuntimeError('Limit must be less than the number of items');\n  }\n\n  let remainingItemsToShuffle = items.length;\n  const lowerBound = limit % items.length === 0 ? 1 : items.length - limit;\n\n  while (remainingItemsToShuffle > lowerBound) {\n    // Pick a remaining element\n    const randomIndex = Math.floor(Math.random() * remainingItemsToShuffle);\n    remainingItemsToShuffle -= 1; // And swap it with the current element\n\n    const swapHold = items[remainingItemsToShuffle];\n    items[remainingItemsToShuffle] = items[randomIndex];\n    items[randomIndex] = swapHold;\n  }\n\n  return limit % items.length === 0 ? items : items.slice(lowerBound);\n}\n\nexports.shuffle = shuffle; // TODO(NODE-4936): read concern eligibility for commands should be codified in command construction\n// @see https://github.com/mongodb/specifications/blob/master/source/read-write-concern/read-write-concern.rst#read-concern\n\nfunction commandSupportsReadConcern(command, options) {\n  if (command.aggregate || command.count || command.distinct || command.find || command.geoNear) {\n    return true;\n  }\n\n  if (command.mapReduce && options && options.out && (options.out.inline === 1 || options.out === 'inline')) {\n    return true;\n  }\n\n  return false;\n}\n\nexports.commandSupportsReadConcern = commandSupportsReadConcern;\n/** A utility function to get the instance of mongodb-client-encryption, if it exists. */\n\nfunction getMongoDBClientEncryption() {\n  let mongodbClientEncryption = null; // NOTE(NODE-4254): This is to get around the circular dependency between\n  // mongodb-client-encryption and the driver in the test scenarios.\n\n  if (typeof process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE === 'string' && process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE.length > 0) {\n    try {\n      // NOTE(NODE-3199): Ensure you always wrap an optional require literally in the try block\n      // Cannot be moved to helper utility function, bundlers search and replace the actual require call\n      // in a way that makes this line throw at bundle time, not runtime, catching here will make bundling succeed\n      mongodbClientEncryption = require(process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE);\n    } catch {// ignore\n    }\n  } else {\n    try {\n      // NOTE(NODE-3199): Ensure you always wrap an optional require literally in the try block\n      // Cannot be moved to helper utility function, bundlers search and replace the actual require call\n      // in a way that makes this line throw at bundle time, not runtime, catching here will make bundling succeed\n      mongodbClientEncryption = require('mongodb-client-encryption');\n    } catch {// ignore\n    }\n  }\n\n  return mongodbClientEncryption;\n}\n\nexports.getMongoDBClientEncryption = getMongoDBClientEncryption;\n/**\n * Compare objectIds. `null` is always less\n * - `+1 = oid1 is greater than oid2`\n * - `-1 = oid1 is less than oid2`\n * - `+0 = oid1 is equal oid2`\n */\n\nfunction compareObjectId(oid1, oid2) {\n  if (oid1 == null && oid2 == null) {\n    return 0;\n  }\n\n  if (oid1 == null) {\n    return -1;\n  }\n\n  if (oid2 == null) {\n    return 1;\n  }\n\n  return exports.ByteUtils.compare(oid1.id, oid2.id);\n}\n\nexports.compareObjectId = compareObjectId;\n\nfunction parseInteger(value) {\n  if (typeof value === 'number') return Math.trunc(value);\n  const parsedValue = Number.parseInt(String(value), 10);\n  return Number.isNaN(parsedValue) ? null : parsedValue;\n}\n\nexports.parseInteger = parseInteger;\n\nfunction parseUnsignedInteger(value) {\n  const parsedInt = parseInteger(value);\n  return parsedInt != null && parsedInt >= 0 ? parsedInt : null;\n}\n\nexports.parseUnsignedInteger = parseUnsignedInteger;","map":{"version":3,"mappings":"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","names":["exports","toLocalBufferType","buffer","Buffer","isBuffer","from","byteOffset","byteLength","equals","seqA","seqB","compare","toBase64","uint8array","toString","checkCollectionName","collectionName","error_1","indexOf","match","normalizeHintField","hint","finalHint","undefined","Array","isArray","forEach","param","name","TO_STRING","object","Object","prototype","call","isObject","arg","mergeOptions","target","source","filterOptions","options","names","includes","applyRetryableWrites","db","s","retryWrites","applyWriteConcern","sources","coll","collection","session","inTransaction","writeConcern","write_concern_1","fromOptions","assign","isPromiseLike","value","then","decorateWithCollation","command","capabilities","getTopology","collation","commandsTakeCollation","decorateWithReadConcern","readConcern","keys","length","decorateWithExplain","explain","verbosity","provider","topology","client","ns","MongoDBNamespace","fromString","constructor","withCollection","namespace","collectionParts","split","join","makeCounter","seed","count","newCount","maybeCallback","promiseFn","callback","promise","result","error","databaseNamespace","uuidV4","crypto","randomBytes","maxWireVersion","topologyOrServer","loadBalanced","constants_1","hello","lastHello","description","eachAsync","arr","eachFn","idx","awaiting","eachCallback","err","eachAsyncSeries","arrayStrictEqual","arr2","every","elt","errorStrictEqual","lhs","rhs","message","makeStateMachine","stateTable","stateTransition","newState","legalStates","state","emit","NODE_DRIVER_VERSION","require","version","makeClientMetadata","metadata","driver","os","type","process","platform","architecture","arch","release","endianness","driverInfo","appName","application","slice","now","hrtime","Math","floor","calculateDurationInMs","started","elapsed","hasAtomicOperators","doc","document","resolveOptions","parent","read_concern_1","readPreference","read_preference_1","isSuperset","set","subset","Set","elem","has","isHello","constants_2","setDifference","setA","setB","difference","delete","HAS_OWN","prop","hasOwnProperty","isRecord","requiredKeys","ctor","deepCopy","map","item","res","key","toLowerCase","Number","Map","List","Symbol","toStringTag","head","next","prev","toArray","iterator","node","nodes","ptr","push","newNode","pushMany","iterable","unshift","remove","prevNode","nextNode","shift","pop","prune","filter","clear","first","last","BufferPool","buffers","totalByteLength","append","getInt32","firstBuffer","readInt32LE","top4Bytes","read","size","alloc","allocUnsafe","bytesRead","bytesRemaining","bytesReadable","min","bytes","subarray","HostAddress","hostString","escapedHost","endsWith","socketPath","decodeURIComponent","urlString","url","url_1","urlError","runtimeError","cause","hostname","port","normalized","startsWith","isIPv6","substring","host","parseInt","freeze","for","inspect","fromHostPort","fromSrvRecord","createPk","bson_1","emitWarning","code","emittedWarnings","emitWarningOnce","add","enumToString","en","values","supportsRetryableWrites","server","logicalSessionTimeoutMinutes","common_1","Standalone","shuffle","sequence","limit","items","remainingItemsToShuffle","lowerBound","randomIndex","random","swapHold","commandSupportsReadConcern","aggregate","distinct","find","geoNear","mapReduce","out","inline","getMongoDBClientEncryption","mongodbClientEncryption","env","MONGODB_CLIENT_ENCRYPTION_OVERRIDE","compareObjectId","oid1","oid2","id","parseInteger","trunc","parsedValue","String","isNaN","parseUnsignedInteger","parsedInt"],"sources":["C:\\Users\\anshs\\OneDrive\\Documents\\Code\\WebDevelopement\\portfolioPersonal\\node_modules\\mongodb\\src\\utils.ts"],"sourcesContent":["import * as crypto from 'crypto';\nimport type { SrvRecord } from 'dns';\nimport * as os from 'os';\nimport { URL } from 'url';\n\nimport { Document, ObjectId, resolveBSONOptions } from './bson';\nimport type { Connection } from './cmap/connection';\nimport { MAX_SUPPORTED_WIRE_VERSION } from './cmap/wire_protocol/constants';\nimport type { Collection } from './collection';\nimport { LEGACY_HELLO_COMMAND } from './constants';\nimport type { AbstractCursor } from './cursor/abstract_cursor';\nimport type { FindCursor } from './cursor/find_cursor';\nimport type { Db } from './db';\nimport {\n  AnyError,\n  MongoCompatibilityError,\n  MongoInvalidArgumentError,\n  MongoNotConnectedError,\n  MongoParseError,\n  MongoRuntimeError\n} from './error';\nimport type { Explain } from './explain';\nimport type { MongoClient } from './mongo_client';\nimport type { CommandOperationOptions, OperationParent } from './operations/command';\nimport type { Hint, OperationOptions } from './operations/operation';\nimport { ReadConcern } from './read_concern';\nimport { ReadPreference } from './read_preference';\nimport { ServerType } from './sdam/common';\nimport type { Server } from './sdam/server';\nimport type { Topology } from './sdam/topology';\nimport type { ClientSession } from './sessions';\nimport { W, WriteConcern, WriteConcernOptions } from './write_concern';\n\n/**\n * MongoDB Driver style callback\n * @public\n */\nexport type Callback<T = any> = (error?: AnyError, result?: T) => void;\n\nexport type AnyOptions = Document;\n\nexport const ByteUtils = {\n  toLocalBufferType(this: void, buffer: Buffer | Uint8Array): Buffer {\n    return Buffer.isBuffer(buffer)\n      ? buffer\n      : Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  },\n\n  equals(this: void, seqA: Uint8Array, seqB: Uint8Array) {\n    return ByteUtils.toLocalBufferType(seqA).equals(seqB);\n  },\n\n  compare(this: void, seqA: Uint8Array, seqB: Uint8Array) {\n    return ByteUtils.toLocalBufferType(seqA).compare(seqB);\n  },\n\n  toBase64(this: void, uint8array: Uint8Array) {\n    return ByteUtils.toLocalBufferType(uint8array).toString('base64');\n  }\n};\n\n/**\n * Throws if collectionName is not a valid mongodb collection namespace.\n * @internal\n */\nexport function checkCollectionName(collectionName: string): void {\n  if ('string' !== typeof collectionName) {\n    throw new MongoInvalidArgumentError('Collection name must be a String');\n  }\n\n  if (!collectionName || collectionName.indexOf('..') !== -1) {\n    throw new MongoInvalidArgumentError('Collection names cannot be empty');\n  }\n\n  if (\n    collectionName.indexOf('$') !== -1 &&\n    collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null\n  ) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new MongoInvalidArgumentError(\"Collection names must not contain '$'\");\n  }\n\n  if (collectionName.match(/^\\.|\\.$/) != null) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new MongoInvalidArgumentError(\"Collection names must not start or end with '.'\");\n  }\n\n  // Validate that we are not passing 0x00 in the collection name\n  if (collectionName.indexOf('\\x00') !== -1) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new MongoInvalidArgumentError('Collection names cannot contain a null character');\n  }\n}\n\n/**\n * Ensure Hint field is in a shape we expect:\n * - object of index names mapping to 1 or -1\n * - just an index name\n * @internal\n */\nexport function normalizeHintField(hint?: Hint): Hint | undefined {\n  let finalHint = undefined;\n\n  if (typeof hint === 'string') {\n    finalHint = hint;\n  } else if (Array.isArray(hint)) {\n    finalHint = {};\n\n    hint.forEach(param => {\n      finalHint[param] = 1;\n    });\n  } else if (hint != null && typeof hint === 'object') {\n    finalHint = {} as Document;\n    for (const name in hint) {\n      finalHint[name] = hint[name];\n    }\n  }\n\n  return finalHint;\n}\n\nconst TO_STRING = (object: unknown) => Object.prototype.toString.call(object);\n/**\n * Checks if arg is an Object:\n * - **NOTE**: the check is based on the `[Symbol.toStringTag]() === 'Object'`\n * @internal\n */\n\nexport function isObject(arg: unknown): arg is object {\n  return '[object Object]' === TO_STRING(arg);\n}\n\n/** @internal */\nexport function mergeOptions<T, S>(target: T, source: S): T & S {\n  return { ...target, ...source };\n}\n\n/** @internal */\nexport function filterOptions(options: AnyOptions, names: ReadonlyArray<string>): AnyOptions {\n  const filterOptions: AnyOptions = {};\n\n  for (const name in options) {\n    if (names.includes(name)) {\n      filterOptions[name] = options[name];\n    }\n  }\n\n  // Filtered options\n  return filterOptions;\n}\n\ninterface HasRetryableWrites {\n  retryWrites?: boolean;\n}\n/**\n * Applies retryWrites: true to a command if retryWrites is set on the command's database.\n * @internal\n *\n * @param target - The target command to which we will apply retryWrites.\n * @param db - The database from which we can inherit a retryWrites value.\n */\nexport function applyRetryableWrites<T extends HasRetryableWrites>(target: T, db?: Db): T {\n  if (db && db.s.options?.retryWrites) {\n    target.retryWrites = true;\n  }\n\n  return target;\n}\n\ninterface HasWriteConcern {\n  writeConcern?: WriteConcernOptions | WriteConcern | W;\n}\n/**\n * Applies a write concern to a command based on well defined inheritance rules, optionally\n * detecting support for the write concern in the first place.\n * @internal\n *\n * @param target - the target command we will be applying the write concern to\n * @param sources - sources where we can inherit default write concerns from\n * @param options - optional settings passed into a command for write concern overrides\n */\nexport function applyWriteConcern<T extends HasWriteConcern>(\n  target: T,\n  sources: { db?: Db; collection?: Collection },\n  options?: OperationOptions & WriteConcernOptions\n): T {\n  options = options ?? {};\n  const db = sources.db;\n  const coll = sources.collection;\n\n  if (options.session && options.session.inTransaction()) {\n    // writeConcern is not allowed within a multi-statement transaction\n    if (target.writeConcern) {\n      delete target.writeConcern;\n    }\n\n    return target;\n  }\n\n  const writeConcern = WriteConcern.fromOptions(options);\n  if (writeConcern) {\n    return Object.assign(target, { writeConcern });\n  }\n\n  if (coll && coll.writeConcern) {\n    return Object.assign(target, { writeConcern: Object.assign({}, coll.writeConcern) });\n  }\n\n  if (db && db.writeConcern) {\n    return Object.assign(target, { writeConcern: Object.assign({}, db.writeConcern) });\n  }\n\n  return target;\n}\n\n/**\n * Checks if a given value is a Promise\n *\n * @typeParam T - The resolution type of the possible promise\n * @param value - An object that could be a promise\n * @returns true if the provided value is a Promise\n */\nexport function isPromiseLike<T = any>(value?: PromiseLike<T> | void): value is Promise<T> {\n  return !!value && typeof value.then === 'function';\n}\n\n/**\n * Applies collation to a given command.\n * @internal\n *\n * @param command - the command on which to apply collation\n * @param target - target of command\n * @param options - options containing collation settings\n */\nexport function decorateWithCollation(\n  command: Document,\n  target: MongoClient | Db | Collection,\n  options: AnyOptions\n): void {\n  const capabilities = getTopology(target).capabilities;\n  if (options.collation && typeof options.collation === 'object') {\n    if (capabilities && capabilities.commandsTakeCollation) {\n      command.collation = options.collation;\n    } else {\n      throw new MongoCompatibilityError(`Current topology does not support collation`);\n    }\n  }\n}\n\n/**\n * Applies a read concern to a given command.\n * @internal\n *\n * @param command - the command on which to apply the read concern\n * @param coll - the parent collection of the operation calling this method\n */\nexport function decorateWithReadConcern(\n  command: Document,\n  coll: { s: { readConcern?: ReadConcern } },\n  options?: OperationOptions\n): void {\n  if (options && options.session && options.session.inTransaction()) {\n    return;\n  }\n  const readConcern = Object.assign({}, command.readConcern || {});\n  if (coll.s.readConcern) {\n    Object.assign(readConcern, coll.s.readConcern);\n  }\n\n  if (Object.keys(readConcern).length > 0) {\n    Object.assign(command, { readConcern: readConcern });\n  }\n}\n\n/**\n * Applies an explain to a given command.\n * @internal\n *\n * @param command - the command on which to apply the explain\n * @param options - the options containing the explain verbosity\n */\nexport function decorateWithExplain(command: Document, explain: Explain): Document {\n  if (command.explain) {\n    return command;\n  }\n\n  return { explain: command, verbosity: explain.verbosity };\n}\n\n/**\n * @internal\n */\nexport type TopologyProvider =\n  | MongoClient\n  | ClientSession\n  | FindCursor\n  | AbstractCursor\n  | Collection<any>\n  | Db;\n\n/**\n * A helper function to get the topology from a given provider. Throws\n * if the topology cannot be found.\n * @throws MongoNotConnectedError\n * @internal\n */\nexport function getTopology(provider: TopologyProvider): Topology {\n  // MongoClient or ClientSession or AbstractCursor\n  if ('topology' in provider && provider.topology) {\n    return provider.topology;\n  } else if ('s' in provider && 'client' in provider.s && provider.s.client.topology) {\n    return provider.s.client.topology;\n  } else if ('s' in provider && 'db' in provider.s && provider.s.db.s.client.topology) {\n    return provider.s.db.s.client.topology;\n  }\n\n  throw new MongoNotConnectedError('MongoClient must be connected to perform this operation');\n}\n\n/** @internal */\nexport function ns(ns: string): MongoDBNamespace {\n  return MongoDBNamespace.fromString(ns);\n}\n\n/** @public */\nexport class MongoDBNamespace {\n  db: string;\n  collection: string | undefined;\n  /**\n   * Create a namespace object\n   *\n   * @param db - database name\n   * @param collection - collection name\n   */\n  constructor(db: string, collection?: string) {\n    this.db = db;\n    this.collection = collection === '' ? undefined : collection;\n  }\n\n  toString(): string {\n    return this.collection ? `${this.db}.${this.collection}` : this.db;\n  }\n\n  withCollection(collection: string): MongoDBNamespace {\n    return new MongoDBNamespace(this.db, collection);\n  }\n\n  static fromString(namespace?: string): MongoDBNamespace {\n    if (typeof namespace !== 'string' || namespace === '') {\n      // TODO(NODE-3483): Replace with MongoNamespaceError\n      throw new MongoRuntimeError(`Cannot parse namespace from \"${namespace}\"`);\n    }\n\n    const [db, ...collectionParts] = namespace.split('.');\n    const collection = collectionParts.join('.');\n    return new MongoDBNamespace(db, collection === '' ? undefined : collection);\n  }\n}\n\n/** @internal */\nexport function* makeCounter(seed = 0): Generator<number> {\n  let count = seed;\n  while (true) {\n    const newCount = count;\n    count += 1;\n    yield newCount;\n  }\n}\n\n/**\n * Helper for handling legacy callback support.\n */\nexport function maybeCallback<T>(promiseFn: () => Promise<T>, callback: null): Promise<T>;\nexport function maybeCallback<T>(\n  promiseFn: () => Promise<T>,\n  callback?: Callback<T>\n): Promise<T> | void;\nexport function maybeCallback<T>(\n  promiseFn: () => Promise<T>,\n  callback?: Callback<T> | null\n): Promise<T> | void {\n  const promise = promiseFn();\n  if (callback == null) {\n    return promise;\n  }\n\n  promise.then(\n    result => callback(undefined, result),\n    error => callback(error)\n  );\n  return;\n}\n\n/** @internal */\nexport function databaseNamespace(ns: string): string {\n  return ns.split('.')[0];\n}\n\n/**\n * Synchronously Generate a UUIDv4\n * @internal\n */\nexport function uuidV4(): Buffer {\n  const result = crypto.randomBytes(16);\n  result[6] = (result[6] & 0x0f) | 0x40;\n  result[8] = (result[8] & 0x3f) | 0x80;\n  return result;\n}\n\n/**\n * A helper function for determining `maxWireVersion` between legacy and new topology instances\n * @internal\n */\nexport function maxWireVersion(topologyOrServer?: Connection | Topology | Server): number {\n  if (topologyOrServer) {\n    if (topologyOrServer.loadBalanced) {\n      // Since we do not have a monitor, we assume the load balanced server is always\n      // pointed at the latest mongodb version. There is a risk that for on-prem\n      // deployments that don't upgrade immediately that this could alert to the\n      // application that a feature is available that is actually not.\n      return MAX_SUPPORTED_WIRE_VERSION;\n    }\n    if (topologyOrServer.hello) {\n      return topologyOrServer.hello.maxWireVersion;\n    }\n\n    if ('lastHello' in topologyOrServer && typeof topologyOrServer.lastHello === 'function') {\n      const lastHello = topologyOrServer.lastHello();\n      if (lastHello) {\n        return lastHello.maxWireVersion;\n      }\n    }\n\n    if (\n      topologyOrServer.description &&\n      'maxWireVersion' in topologyOrServer.description &&\n      topologyOrServer.description.maxWireVersion != null\n    ) {\n      return topologyOrServer.description.maxWireVersion;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * Applies the function `eachFn` to each item in `arr`, in parallel.\n * @internal\n *\n * @param arr - An array of items to asynchronously iterate over\n * @param eachFn - A function to call on each item of the array. The callback signature is `(item, callback)`, where the callback indicates iteration is complete.\n * @param callback - The callback called after every item has been iterated\n */\nexport function eachAsync<T = Document>(\n  arr: T[],\n  eachFn: (item: T, callback: (err?: AnyError) => void) => void,\n  callback: Callback\n): void {\n  arr = arr || [];\n\n  let idx = 0;\n  let awaiting = 0;\n  for (idx = 0; idx < arr.length; ++idx) {\n    awaiting++;\n    eachFn(arr[idx], eachCallback);\n  }\n\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n\n  function eachCallback(err?: AnyError) {\n    awaiting--;\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n    }\n  }\n}\n\n/** @internal */\nexport function eachAsyncSeries<T = any>(\n  arr: T[],\n  eachFn: (item: T, callback: (err?: AnyError) => void) => void,\n  callback: Callback\n): void {\n  arr = arr || [];\n\n  let idx = 0;\n  let awaiting = arr.length;\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n\n  function eachCallback(err?: AnyError) {\n    idx++;\n    awaiting--;\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n      return;\n    }\n\n    eachFn(arr[idx], eachCallback);\n  }\n\n  eachFn(arr[idx], eachCallback);\n}\n\n/** @internal */\nexport function arrayStrictEqual(arr: unknown[], arr2: unknown[]): boolean {\n  if (!Array.isArray(arr) || !Array.isArray(arr2)) {\n    return false;\n  }\n\n  return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);\n}\n\n/** @internal */\nexport function errorStrictEqual(lhs?: AnyError | null, rhs?: AnyError | null): boolean {\n  if (lhs === rhs) {\n    return true;\n  }\n\n  if (!lhs || !rhs) {\n    return lhs === rhs;\n  }\n\n  if ((lhs == null && rhs != null) || (lhs != null && rhs == null)) {\n    return false;\n  }\n\n  if (lhs.constructor.name !== rhs.constructor.name) {\n    return false;\n  }\n\n  if (lhs.message !== rhs.message) {\n    return false;\n  }\n\n  return true;\n}\n\ninterface StateTable {\n  [key: string]: string[];\n}\ninterface ObjectWithState {\n  s: { state: string };\n  emit(event: 'stateChanged', state: string, newState: string): void;\n}\ninterface StateTransitionFunction {\n  (target: ObjectWithState, newState: string): void;\n}\n\n/** @public */\nexport type EventEmitterWithState = {\n  /** @internal */\n  stateChanged(previous: string, current: string): void;\n};\n\n/** @internal */\nexport function makeStateMachine(stateTable: StateTable): StateTransitionFunction {\n  return function stateTransition(target, newState) {\n    const legalStates = stateTable[target.s.state];\n    if (legalStates && legalStates.indexOf(newState) < 0) {\n      throw new MongoRuntimeError(\n        `illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`\n      );\n    }\n\n    target.emit('stateChanged', target.s.state, newState);\n    target.s.state = newState;\n  };\n}\n\n/** @public */\nexport interface ClientMetadata {\n  driver: {\n    name: string;\n    version: string;\n  };\n  os: {\n    type: string;\n    name: NodeJS.Platform;\n    architecture: string;\n    version: string;\n  };\n  platform: string;\n  version?: string;\n  application?: {\n    name: string;\n  };\n}\n\n/** @public */\nexport interface ClientMetadataOptions {\n  driverInfo?: {\n    name?: string;\n    version?: string;\n    platform?: string;\n  };\n  appName?: string;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst NODE_DRIVER_VERSION = require('../package.json').version;\n\nexport function makeClientMetadata(options?: ClientMetadataOptions): ClientMetadata {\n  options = options ?? {};\n\n  const metadata: ClientMetadata = {\n    driver: {\n      name: 'nodejs',\n      version: NODE_DRIVER_VERSION\n    },\n    os: {\n      type: os.type(),\n      name: process.platform,\n      architecture: process.arch,\n      version: os.release()\n    },\n    platform: `Node.js ${process.version}, ${os.endianness()} (unified)`\n  };\n\n  // support optionally provided wrapping driver info\n  if (options.driverInfo) {\n    if (options.driverInfo.name) {\n      metadata.driver.name = `${metadata.driver.name}|${options.driverInfo.name}`;\n    }\n\n    if (options.driverInfo.version) {\n      metadata.version = `${metadata.driver.version}|${options.driverInfo.version}`;\n    }\n\n    if (options.driverInfo.platform) {\n      metadata.platform = `${metadata.platform}|${options.driverInfo.platform}`;\n    }\n  }\n\n  if (options.appName) {\n    // MongoDB requires the appName not exceed a byte length of 128\n    const buffer = Buffer.from(options.appName);\n    metadata.application = {\n      name: buffer.byteLength > 128 ? buffer.slice(0, 128).toString('utf8') : options.appName\n    };\n  }\n\n  return metadata;\n}\n\n/** @internal */\nexport function now(): number {\n  const hrtime = process.hrtime();\n  return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);\n}\n\n/** @internal */\nexport function calculateDurationInMs(started: number): number {\n  if (typeof started !== 'number') {\n    throw new MongoInvalidArgumentError('Numeric value required to calculate duration');\n  }\n\n  const elapsed = now() - started;\n  return elapsed < 0 ? 0 : elapsed;\n}\n\n/** @internal */\nexport function hasAtomicOperators(doc: Document | Document[]): boolean {\n  if (Array.isArray(doc)) {\n    for (const document of doc) {\n      if (hasAtomicOperators(document)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  const keys = Object.keys(doc);\n  return keys.length > 0 && keys[0][0] === '$';\n}\n\n/**\n * Merge inherited properties from parent into options, prioritizing values from options,\n * then values from parent.\n * @internal\n */\nexport function resolveOptions<T extends CommandOperationOptions>(\n  parent: OperationParent | undefined,\n  options?: T\n): T {\n  const result: T = Object.assign({}, options, resolveBSONOptions(options, parent));\n\n  // Users cannot pass a readConcern/writeConcern to operations in a transaction\n  const session = options?.session;\n  if (!session?.inTransaction()) {\n    const readConcern = ReadConcern.fromOptions(options) ?? parent?.readConcern;\n    if (readConcern) {\n      result.readConcern = readConcern;\n    }\n\n    const writeConcern = WriteConcern.fromOptions(options) ?? parent?.writeConcern;\n    if (writeConcern) {\n      result.writeConcern = writeConcern;\n    }\n  }\n\n  const readPreference = ReadPreference.fromOptions(options) ?? parent?.readPreference;\n  if (readPreference) {\n    result.readPreference = readPreference;\n  }\n\n  return result;\n}\n\nexport function isSuperset(set: Set<any> | any[], subset: Set<any> | any[]): boolean {\n  set = Array.isArray(set) ? new Set(set) : set;\n  subset = Array.isArray(subset) ? new Set(subset) : subset;\n  for (const elem of subset) {\n    if (!set.has(elem)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Checks if the document is a Hello request\n * @internal\n */\nexport function isHello(doc: Document): boolean {\n  return doc[LEGACY_HELLO_COMMAND] || doc.hello ? true : false;\n}\n\n/** Returns the items that are uniquely in setA */\nexport function setDifference<T>(setA: Iterable<T>, setB: Iterable<T>): Set<T> {\n  const difference = new Set<T>(setA);\n  for (const elem of setB) {\n    difference.delete(elem);\n  }\n  return difference;\n}\n\nconst HAS_OWN = (object: unknown, prop: string) =>\n  Object.prototype.hasOwnProperty.call(object, prop);\n\nexport function isRecord<T extends readonly string[]>(\n  value: unknown,\n  requiredKeys: T\n): value is Record<T[number], any>;\nexport function isRecord(value: unknown): value is Record<string, any>;\nexport function isRecord(\n  value: unknown,\n  requiredKeys: string[] | undefined = undefined\n): value is Record<string, any> {\n  if (!isObject(value)) {\n    return false;\n  }\n\n  const ctor = (value as any).constructor;\n  if (ctor && ctor.prototype) {\n    if (!isObject(ctor.prototype)) {\n      return false;\n    }\n\n    // Check to see if some method exists from the Object exists\n    if (!HAS_OWN(ctor.prototype, 'isPrototypeOf')) {\n      return false;\n    }\n  }\n\n  if (requiredKeys) {\n    const keys = Object.keys(value as Record<string, any>);\n    return isSuperset(keys, requiredKeys);\n  }\n\n  return true;\n}\n\n/**\n * Make a deep copy of an object\n *\n * NOTE: This is not meant to be the perfect implementation of a deep copy,\n * but instead something that is good enough for the purposes of\n * command monitoring.\n */\nexport function deepCopy<T>(value: T): T {\n  if (value == null) {\n    return value;\n  } else if (Array.isArray(value)) {\n    return value.map(item => deepCopy(item)) as unknown as T;\n  } else if (isRecord(value)) {\n    const res = {} as any;\n    for (const key in value) {\n      res[key] = deepCopy(value[key]);\n    }\n    return res;\n  }\n\n  const ctor = (value as any).constructor;\n  if (ctor) {\n    switch (ctor.name.toLowerCase()) {\n      case 'date':\n        return new ctor(Number(value));\n      case 'map':\n        return new Map(value as any) as unknown as T;\n      case 'set':\n        return new Set(value as any) as unknown as T;\n      case 'buffer':\n        return Buffer.from(value as unknown as Buffer) as unknown as T;\n    }\n  }\n\n  return value;\n}\n\ntype ListNode<T> = {\n  value: T;\n  next: ListNode<T> | HeadNode<T>;\n  prev: ListNode<T> | HeadNode<T>;\n};\n\ntype HeadNode<T> = {\n  value: null;\n  next: ListNode<T>;\n  prev: ListNode<T>;\n};\n\n/**\n * When a list is empty the head is a reference with pointers to itself\n * So this type represents that self referential state\n */\ntype EmptyNode = {\n  value: null;\n  next: EmptyNode;\n  prev: EmptyNode;\n};\n\n/**\n * A sequential list of items in a circularly linked list\n * @remarks\n * The head node is special, it is always defined and has a value of null.\n * It is never \"included\" in the list, in that, it is not returned by pop/shift or yielded by the iterator.\n * The circular linkage and always defined head node are to reduce checks for null next/prev references to zero.\n * New nodes are declared as object literals with keys always in the same order: next, prev, value.\n * @internal\n */\nexport class List<T = unknown> {\n  private readonly head: HeadNode<T> | EmptyNode;\n  private count: number;\n\n  get length() {\n    return this.count;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'List' as const;\n  }\n\n  constructor() {\n    this.count = 0;\n\n    // this is carefully crafted:\n    // declaring a complete and consistently key ordered\n    // object is beneficial to the runtime optimizations\n    this.head = {\n      next: null,\n      prev: null,\n      value: null\n    } as unknown as EmptyNode;\n    this.head.next = this.head;\n    this.head.prev = this.head;\n  }\n\n  toArray() {\n    return Array.from(this);\n  }\n\n  toString() {\n    return `head <=> ${this.toArray().join(' <=> ')} <=> head`;\n  }\n\n  *[Symbol.iterator](): Generator<T, void, void> {\n    for (const node of this.nodes()) {\n      yield node.value;\n    }\n  }\n\n  private *nodes(): Generator<ListNode<T>, void, void> {\n    let ptr: HeadNode<T> | ListNode<T> | EmptyNode = this.head.next;\n    while (ptr !== this.head) {\n      // Save next before yielding so that we make removing within iteration safe\n      const { next } = ptr as ListNode<T>;\n      yield ptr as ListNode<T>;\n      ptr = next;\n    }\n  }\n\n  /** Insert at end of list */\n  push(value: T) {\n    this.count += 1;\n    const newNode: ListNode<T> = {\n      next: this.head as HeadNode<T>,\n      prev: this.head.prev as ListNode<T>,\n      value\n    };\n    this.head.prev.next = newNode;\n    this.head.prev = newNode;\n  }\n\n  /** Inserts every item inside an iterable instead of the iterable itself */\n  pushMany(iterable: Iterable<T>) {\n    for (const value of iterable) {\n      this.push(value);\n    }\n  }\n\n  /** Insert at front of list */\n  unshift(value: T) {\n    this.count += 1;\n    const newNode: ListNode<T> = {\n      next: this.head.next as ListNode<T>,\n      prev: this.head as HeadNode<T>,\n      value\n    };\n    this.head.next.prev = newNode;\n    this.head.next = newNode;\n  }\n\n  private remove(node: ListNode<T> | EmptyNode): T | null {\n    if (node === this.head || this.length === 0) {\n      return null;\n    }\n\n    this.count -= 1;\n\n    const prevNode = node.prev;\n    const nextNode = node.next;\n    prevNode.next = nextNode;\n    nextNode.prev = prevNode;\n\n    return node.value;\n  }\n\n  /** Removes the first node at the front of the list */\n  shift(): T | null {\n    return this.remove(this.head.next);\n  }\n\n  /** Removes the last node at the end of the list */\n  pop(): T | null {\n    return this.remove(this.head.prev);\n  }\n\n  /** Iterates through the list and removes nodes where filter returns true */\n  prune(filter: (value: T) => boolean) {\n    for (const node of this.nodes()) {\n      if (filter(node.value)) {\n        this.remove(node);\n      }\n    }\n  }\n\n  clear() {\n    this.count = 0;\n    this.head.next = this.head as EmptyNode;\n    this.head.prev = this.head as EmptyNode;\n  }\n\n  /** Returns the first item in the list, does not remove */\n  first(): T | null {\n    // If the list is empty, value will be the head's null\n    return this.head.next.value;\n  }\n\n  /** Returns the last item in the list, does not remove */\n  last(): T | null {\n    // If the list is empty, value will be the head's null\n    return this.head.prev.value;\n  }\n}\n\n/**\n * A pool of Buffers which allow you to read them as if they were one\n * @internal\n */\nexport class BufferPool {\n  private buffers: List<Buffer>;\n  private totalByteLength: number;\n\n  constructor() {\n    this.buffers = new List();\n    this.totalByteLength = 0;\n  }\n\n  get length(): number {\n    return this.totalByteLength;\n  }\n\n  /** Adds a buffer to the internal buffer pool list */\n  append(buffer: Buffer): void {\n    this.buffers.push(buffer);\n    this.totalByteLength += buffer.length;\n  }\n\n  /**\n   * If BufferPool contains 4 bytes or more construct an int32 from the leading bytes,\n   * otherwise return null. Size can be negative, caller should error check.\n   */\n  getInt32(): number | null {\n    if (this.totalByteLength < 4) {\n      return null;\n    }\n    const firstBuffer = this.buffers.first();\n    if (firstBuffer != null && firstBuffer.byteLength >= 4) {\n      return firstBuffer.readInt32LE(0);\n    }\n\n    // Unlikely case: an int32 is split across buffers.\n    // Use read and put the returned buffer back on top\n    const top4Bytes = this.read(4);\n    const value = top4Bytes.readInt32LE(0);\n\n    // Put it back.\n    this.totalByteLength += 4;\n    this.buffers.unshift(top4Bytes);\n\n    return value;\n  }\n\n  /** Reads the requested number of bytes, optionally consuming them */\n  read(size: number): Buffer {\n    if (typeof size !== 'number' || size < 0) {\n      throw new MongoInvalidArgumentError('Argument \"size\" must be a non-negative number');\n    }\n\n    // oversized request returns empty buffer\n    if (size > this.totalByteLength) {\n      return Buffer.alloc(0);\n    }\n\n    // We know we have enough, we just don't know how it is spread across chunks\n    // TODO(NODE-4732): alloc API should change based on raw option\n    const result = Buffer.allocUnsafe(size);\n\n    for (let bytesRead = 0; bytesRead < size; ) {\n      const buffer = this.buffers.shift();\n      if (buffer == null) {\n        break;\n      }\n      const bytesRemaining = size - bytesRead;\n      const bytesReadable = Math.min(bytesRemaining, buffer.byteLength);\n      const bytes = buffer.subarray(0, bytesReadable);\n\n      result.set(bytes, bytesRead);\n\n      bytesRead += bytesReadable;\n      this.totalByteLength -= bytesReadable;\n      if (bytesReadable < buffer.byteLength) {\n        this.buffers.unshift(buffer.subarray(bytesReadable));\n      }\n    }\n\n    return result;\n  }\n}\n\n/** @public */\nexport class HostAddress {\n  host: string | undefined = undefined;\n  port: number | undefined = undefined;\n  socketPath: string | undefined = undefined;\n  isIPv6 = false;\n\n  constructor(hostString: string) {\n    const escapedHost = hostString.split(' ').join('%20'); // escape spaces, for socket path hosts\n\n    if (escapedHost.endsWith('.sock')) {\n      // heuristically determine if we're working with a domain socket\n      this.socketPath = decodeURIComponent(escapedHost);\n      return;\n    }\n\n    const urlString = `iLoveJS://${escapedHost}`;\n    let url;\n    try {\n      url = new URL(urlString);\n    } catch (urlError) {\n      const runtimeError = new MongoRuntimeError(`Unable to parse ${escapedHost} with URL`);\n      runtimeError.cause = urlError;\n      throw runtimeError;\n    }\n\n    const hostname = url.hostname;\n    const port = url.port;\n\n    let normalized = decodeURIComponent(hostname).toLowerCase();\n    if (normalized.startsWith('[') && normalized.endsWith(']')) {\n      this.isIPv6 = true;\n      normalized = normalized.substring(1, hostname.length - 1);\n    }\n\n    this.host = normalized.toLowerCase();\n\n    if (typeof port === 'number') {\n      this.port = port;\n    } else if (typeof port === 'string' && port !== '') {\n      this.port = Number.parseInt(port, 10);\n    } else {\n      this.port = 27017;\n    }\n\n    if (this.port === 0) {\n      throw new MongoParseError('Invalid port (zero) with hostname');\n    }\n    Object.freeze(this);\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')](): string {\n    return this.inspect();\n  }\n\n  inspect(): string {\n    return `new HostAddress('${this.toString()}')`;\n  }\n\n  toString(): string {\n    if (typeof this.host === 'string') {\n      if (this.isIPv6) {\n        return `[${this.host}]:${this.port}`;\n      }\n      return `${this.host}:${this.port}`;\n    }\n    return `${this.socketPath}`;\n  }\n\n  static fromString(this: void, s: string): HostAddress {\n    return new HostAddress(s);\n  }\n\n  static fromHostPort(host: string, port: number): HostAddress {\n    if (host.includes(':')) {\n      host = `[${host}]`; // IPv6 address\n    }\n    return HostAddress.fromString(`${host}:${port}`);\n  }\n\n  static fromSrvRecord({ name, port }: SrvRecord): HostAddress {\n    return HostAddress.fromHostPort(name, port);\n  }\n}\n\nexport const DEFAULT_PK_FACTORY = {\n  // We prefer not to rely on ObjectId having a createPk method\n  createPk(): ObjectId {\n    return new ObjectId();\n  }\n};\n\n/**\n * When the driver used emitWarning the code will be equal to this.\n * @public\n *\n * @example\n * ```ts\n * process.on('warning', (warning) => {\n *  if (warning.code === MONGODB_WARNING_CODE) console.error('Ah an important warning! :)')\n * })\n * ```\n */\nexport const MONGODB_WARNING_CODE = 'MONGODB DRIVER' as const;\n\n/** @internal */\nexport function emitWarning(message: string): void {\n  return process.emitWarning(message, { code: MONGODB_WARNING_CODE } as any);\n}\n\nconst emittedWarnings = new Set();\n/**\n * Will emit a warning once for the duration of the application.\n * Uses the message to identify if it has already been emitted\n * so using string interpolation can cause multiple emits\n * @internal\n */\nexport function emitWarningOnce(message: string): void {\n  if (!emittedWarnings.has(message)) {\n    emittedWarnings.add(message);\n    return emitWarning(message);\n  }\n}\n\n/**\n * Takes a JS object and joins the values into a string separated by ', '\n */\nexport function enumToString(en: Record<string, unknown>): string {\n  return Object.values(en).join(', ');\n}\n\n/**\n * Determine if a server supports retryable writes.\n *\n * @internal\n */\nexport function supportsRetryableWrites(server?: Server): boolean {\n  if (!server) {\n    return false;\n  }\n\n  if (server.loadBalanced) {\n    // Loadbalanced topologies will always support retry writes\n    return true;\n  }\n\n  if (server.description.logicalSessionTimeoutMinutes != null) {\n    // that supports sessions\n    if (server.description.type !== ServerType.Standalone) {\n      // and that is not a standalone\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Fisher–Yates Shuffle\n *\n * Reference: https://bost.ocks.org/mike/shuffle/\n * @param sequence - items to be shuffled\n * @param limit - Defaults to `0`. If nonzero shuffle will slice the randomized array e.g, `.slice(0, limit)` otherwise will return the entire randomized array.\n */\nexport function shuffle<T>(sequence: Iterable<T>, limit = 0): Array<T> {\n  const items = Array.from(sequence); // shallow copy in order to never shuffle the input\n\n  if (limit > items.length) {\n    throw new MongoRuntimeError('Limit must be less than the number of items');\n  }\n\n  let remainingItemsToShuffle = items.length;\n  const lowerBound = limit % items.length === 0 ? 1 : items.length - limit;\n  while (remainingItemsToShuffle > lowerBound) {\n    // Pick a remaining element\n    const randomIndex = Math.floor(Math.random() * remainingItemsToShuffle);\n    remainingItemsToShuffle -= 1;\n\n    // And swap it with the current element\n    const swapHold = items[remainingItemsToShuffle];\n    items[remainingItemsToShuffle] = items[randomIndex];\n    items[randomIndex] = swapHold;\n  }\n\n  return limit % items.length === 0 ? items : items.slice(lowerBound);\n}\n\n// TODO(NODE-4936): read concern eligibility for commands should be codified in command construction\n// @see https://github.com/mongodb/specifications/blob/master/source/read-write-concern/read-write-concern.rst#read-concern\nexport function commandSupportsReadConcern(command: Document, options?: Document): boolean {\n  if (command.aggregate || command.count || command.distinct || command.find || command.geoNear) {\n    return true;\n  }\n\n  if (\n    command.mapReduce &&\n    options &&\n    options.out &&\n    (options.out.inline === 1 || options.out === 'inline')\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\n/** A utility function to get the instance of mongodb-client-encryption, if it exists. */\nexport function getMongoDBClientEncryption(): {\n  extension: (mdb: unknown) => {\n    AutoEncrypter: any;\n    ClientEncryption: any;\n  };\n} | null {\n  let mongodbClientEncryption = null;\n\n  // NOTE(NODE-4254): This is to get around the circular dependency between\n  // mongodb-client-encryption and the driver in the test scenarios.\n  if (\n    typeof process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE === 'string' &&\n    process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE.length > 0\n  ) {\n    try {\n      // NOTE(NODE-3199): Ensure you always wrap an optional require literally in the try block\n      // Cannot be moved to helper utility function, bundlers search and replace the actual require call\n      // in a way that makes this line throw at bundle time, not runtime, catching here will make bundling succeed\n      mongodbClientEncryption = require(process.env.MONGODB_CLIENT_ENCRYPTION_OVERRIDE);\n    } catch {\n      // ignore\n    }\n  } else {\n    try {\n      // NOTE(NODE-3199): Ensure you always wrap an optional require literally in the try block\n      // Cannot be moved to helper utility function, bundlers search and replace the actual require call\n      // in a way that makes this line throw at bundle time, not runtime, catching here will make bundling succeed\n      mongodbClientEncryption = require('mongodb-client-encryption');\n    } catch {\n      // ignore\n    }\n  }\n\n  return mongodbClientEncryption;\n}\n\n/**\n * Compare objectIds. `null` is always less\n * - `+1 = oid1 is greater than oid2`\n * - `-1 = oid1 is less than oid2`\n * - `+0 = oid1 is equal oid2`\n */\nexport function compareObjectId(oid1?: ObjectId | null, oid2?: ObjectId | null): 0 | 1 | -1 {\n  if (oid1 == null && oid2 == null) {\n    return 0;\n  }\n\n  if (oid1 == null) {\n    return -1;\n  }\n\n  if (oid2 == null) {\n    return 1;\n  }\n\n  return ByteUtils.compare(oid1.id, oid2.id);\n}\n\nexport function parseInteger(value: unknown): number | null {\n  if (typeof value === 'number') return Math.trunc(value);\n  const parsedValue = Number.parseInt(String(value), 10);\n\n  return Number.isNaN(parsedValue) ? null : parsedValue;\n}\n\nexport function parseUnsignedInteger(value: unknown): number | null {\n  const parsedInt = parseInteger(value);\n\n  return parsedInt != null && parsedInt >= 0 ? parsedInt : null;\n}\n"]},"metadata":{},"sourceType":"script"}