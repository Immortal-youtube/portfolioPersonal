{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MongoDBAWS = void 0;\n\nconst crypto = require(\"crypto\");\n\nconst http = require(\"http\");\n\nconst url = require(\"url\");\n\nconst BSON = require(\"../../bson\");\n\nconst deps_1 = require(\"../../deps\");\n\nconst error_1 = require(\"../../error\");\n\nconst utils_1 = require(\"../../utils\");\n\nconst auth_provider_1 = require(\"./auth_provider\");\n\nconst mongo_credentials_1 = require(\"./mongo_credentials\");\n\nconst providers_1 = require(\"./providers\");\n\nconst ASCII_N = 110;\nconst AWS_RELATIVE_URI = 'http://169.254.170.2';\nconst AWS_EC2_URI = 'http://169.254.169.254';\nconst AWS_EC2_PATH = '/latest/meta-data/iam/security-credentials';\nconst bsonOptions = {\n  promoteLongs: true,\n  promoteValues: true,\n  promoteBuffers: false,\n  bsonRegExp: false\n};\n\nclass MongoDBAWS extends auth_provider_1.AuthProvider {\n  auth(authContext, callback) {\n    const {\n      connection,\n      credentials\n    } = authContext;\n\n    if (!credentials) {\n      return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));\n    }\n\n    if ('kModuleError' in deps_1.aws4) {\n      return callback(deps_1.aws4['kModuleError']);\n    }\n\n    const {\n      sign\n    } = deps_1.aws4;\n\n    if ((0, utils_1.maxWireVersion)(connection) < 9) {\n      callback(new error_1.MongoCompatibilityError('MONGODB-AWS authentication requires MongoDB version 4.4 or later'));\n      return;\n    }\n\n    if (!credentials.username) {\n      makeTempCredentials(credentials, (err, tempCredentials) => {\n        if (err || !tempCredentials) return callback(err);\n        authContext.credentials = tempCredentials;\n        this.auth(authContext, callback);\n      });\n      return;\n    }\n\n    const accessKeyId = credentials.username;\n    const secretAccessKey = credentials.password;\n    const sessionToken = credentials.mechanismProperties.AWS_SESSION_TOKEN; // If all three defined, include sessionToken, else include username and pass, else no credentials\n\n    const awsCredentials = accessKeyId && secretAccessKey && sessionToken ? {\n      accessKeyId,\n      secretAccessKey,\n      sessionToken\n    } : accessKeyId && secretAccessKey ? {\n      accessKeyId,\n      secretAccessKey\n    } : undefined;\n    const db = credentials.source;\n    crypto.randomBytes(32, (err, nonce) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      const saslStart = {\n        saslStart: 1,\n        mechanism: 'MONGODB-AWS',\n        payload: BSON.serialize({\n          r: nonce,\n          p: ASCII_N\n        }, bsonOptions)\n      };\n      connection.command((0, utils_1.ns)(`${db}.$cmd`), saslStart, undefined, (err, res) => {\n        if (err) return callback(err);\n        const serverResponse = BSON.deserialize(res.payload.buffer, bsonOptions);\n        const host = serverResponse.h;\n        const serverNonce = serverResponse.s.buffer;\n\n        if (serverNonce.length !== 64) {\n          callback( // TODO(NODE-3483)\n          new error_1.MongoRuntimeError(`Invalid server nonce length ${serverNonce.length}, expected 64`));\n          return;\n        }\n\n        if (!utils_1.ByteUtils.equals(serverNonce.subarray(0, nonce.byteLength), nonce)) {\n          // throw because the serverNonce's leading 32 bytes must equal the client nonce's 32 bytes\n          // https://github.com/mongodb/specifications/blob/875446db44aade414011731840831f38a6c668df/source/auth/auth.rst#id11\n          // TODO(NODE-3483)\n          callback(new error_1.MongoRuntimeError('Server nonce does not begin with client nonce'));\n          return;\n        }\n\n        if (host.length < 1 || host.length > 255 || host.indexOf('..') !== -1) {\n          // TODO(NODE-3483)\n          callback(new error_1.MongoRuntimeError(`Server returned an invalid host: \"${host}\"`));\n          return;\n        }\n\n        const body = 'Action=GetCallerIdentity&Version=2011-06-15';\n        const options = sign({\n          method: 'POST',\n          host,\n          region: deriveRegion(serverResponse.h),\n          service: 'sts',\n          headers: {\n            'Content-Type': 'application/x-www-form-urlencoded',\n            'Content-Length': body.length,\n            'X-MongoDB-Server-Nonce': utils_1.ByteUtils.toBase64(serverNonce),\n            'X-MongoDB-GS2-CB-Flag': 'n'\n          },\n          path: '/',\n          body\n        }, awsCredentials);\n        const payload = {\n          a: options.headers.Authorization,\n          d: options.headers['X-Amz-Date']\n        };\n\n        if (sessionToken) {\n          payload.t = sessionToken;\n        }\n\n        const saslContinue = {\n          saslContinue: 1,\n          conversationId: 1,\n          payload: BSON.serialize(payload, bsonOptions)\n        };\n        connection.command((0, utils_1.ns)(`${db}.$cmd`), saslContinue, undefined, callback);\n      });\n    });\n  }\n\n}\n\nexports.MongoDBAWS = MongoDBAWS;\n\nfunction makeTempCredentials(credentials, callback) {\n  function done(creds) {\n    if (!creds.AccessKeyId || !creds.SecretAccessKey || !creds.Token) {\n      callback(new error_1.MongoMissingCredentialsError('Could not obtain temporary MONGODB-AWS credentials'));\n      return;\n    }\n\n    callback(undefined, new mongo_credentials_1.MongoCredentials({\n      username: creds.AccessKeyId,\n      password: creds.SecretAccessKey,\n      source: credentials.source,\n      mechanism: providers_1.AuthMechanism.MONGODB_AWS,\n      mechanismProperties: {\n        AWS_SESSION_TOKEN: creds.Token\n      }\n    }));\n  }\n\n  const credentialProvider = (0, deps_1.getAwsCredentialProvider)(); // Check if the AWS credential provider from the SDK is present. If not,\n  // use the old method.\n\n  if ('kModuleError' in credentialProvider) {\n    // If the environment variable AWS_CONTAINER_CREDENTIALS_RELATIVE_URI\n    // is set then drivers MUST assume that it was set by an AWS ECS agent\n    if (process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI) {\n      request(`${AWS_RELATIVE_URI}${process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI}`, undefined, (err, res) => {\n        if (err) return callback(err);\n        done(res);\n      });\n      return;\n    } // Otherwise assume we are on an EC2 instance\n    // get a token\n\n\n    request(`${AWS_EC2_URI}/latest/api/token`, {\n      method: 'PUT',\n      json: false,\n      headers: {\n        'X-aws-ec2-metadata-token-ttl-seconds': 30\n      }\n    }, (err, token) => {\n      if (err) return callback(err); // get role name\n\n      request(`${AWS_EC2_URI}/${AWS_EC2_PATH}`, {\n        json: false,\n        headers: {\n          'X-aws-ec2-metadata-token': token\n        }\n      }, (err, roleName) => {\n        if (err) return callback(err); // get temp credentials\n\n        request(`${AWS_EC2_URI}/${AWS_EC2_PATH}/${roleName}`, {\n          headers: {\n            'X-aws-ec2-metadata-token': token\n          }\n        }, (err, creds) => {\n          if (err) return callback(err);\n          done(creds);\n        });\n      });\n    });\n  } else {\n    /*\n     * Creates a credential provider that will attempt to find credentials from the\n     * following sources (listed in order of precedence):\n     *\n     * - Environment variables exposed via process.env\n     * - SSO credentials from token cache\n     * - Web identity token credentials\n     * - Shared credentials and config ini files\n     * - The EC2/ECS Instance Metadata Service\n     */\n    const {\n      fromNodeProviderChain\n    } = credentialProvider;\n    const provider = fromNodeProviderChain();\n    provider().then(creds => {\n      done({\n        AccessKeyId: creds.accessKeyId,\n        SecretAccessKey: creds.secretAccessKey,\n        Token: creds.sessionToken,\n        Expiration: creds.expiration\n      });\n    }).catch(error => {\n      callback(new error_1.MongoAWSError(error.message));\n    });\n  }\n}\n\nfunction deriveRegion(host) {\n  const parts = host.split('.');\n\n  if (parts.length === 1 || parts[1] === 'amazonaws') {\n    return 'us-east-1';\n  }\n\n  return parts[1];\n}\n\nfunction request(uri, _options, callback) {\n  const options = Object.assign({\n    method: 'GET',\n    timeout: 10000,\n    json: true\n  }, url.parse(uri), _options);\n  const req = http.request(options, res => {\n    res.setEncoding('utf8');\n    let data = '';\n    res.on('data', d => data += d);\n    res.on('end', () => {\n      if (options.json === false) {\n        callback(undefined, data);\n        return;\n      }\n\n      try {\n        const parsed = JSON.parse(data);\n        callback(undefined, parsed);\n      } catch (err) {\n        // TODO(NODE-3483)\n        callback(new error_1.MongoRuntimeError(`Invalid JSON response: \"${data}\"`));\n      }\n    });\n  });\n  req.on('timeout', () => {\n    req.destroy(new error_1.MongoAWSError(`AWS request to ${uri} timed out after ${options.timeout} ms`));\n  });\n  req.on('error', err => callback(err));\n  req.end();\n}","map":{"version":3,"mappings":"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","names":["ASCII_N","AWS_RELATIVE_URI","AWS_EC2_URI","AWS_EC2_PATH","bsonOptions","promoteLongs","promoteValues","promoteBuffers","bsonRegExp","MongoDBAWS","auth_provider_1","auth","authContext","callback","connection","credentials","error_1","deps_1","sign","username","makeTempCredentials","err","tempCredentials","accessKeyId","secretAccessKey","password","sessionToken","mechanismProperties","AWS_SESSION_TOKEN","awsCredentials","undefined","db","source","crypto","randomBytes","nonce","saslStart","mechanism","payload","BSON","serialize","r","p","command","res","serverResponse","deserialize","buffer","host","h","serverNonce","s","length","utils_1","equals","subarray","byteLength","indexOf","body","options","method","region","deriveRegion","service","headers","toBase64","path","a","Authorization","d","t","saslContinue","conversationId","exports","done","creds","AccessKeyId","SecretAccessKey","Token","mongo_credentials_1","providers_1","MONGODB_AWS","credentialProvider","process","env","AWS_CONTAINER_CREDENTIALS_RELATIVE_URI","request","json","token","roleName","fromNodeProviderChain","provider","then","Expiration","expiration","catch","error","message","parts","split","uri","_options","Object","assign","timeout","url","parse","req","http","setEncoding","data","on","parsed","JSON","destroy","end"],"sources":["C:\\Users\\anshs\\OneDrive\\Documents\\Code\\WebDevelopement\\portfolioPersonal\\node_modules\\mongodb\\src\\cmap\\auth\\mongodb_aws.ts"],"sourcesContent":["import * as crypto from 'crypto';\nimport * as http from 'http';\nimport * as url from 'url';\n\nimport type { Binary, BSONSerializeOptions } from '../../bson';\nimport * as BSON from '../../bson';\nimport { aws4, getAwsCredentialProvider } from '../../deps';\nimport {\n  MongoAWSError,\n  MongoCompatibilityError,\n  MongoMissingCredentialsError,\n  MongoRuntimeError\n} from '../../error';\nimport { ByteUtils, Callback, maxWireVersion, ns } from '../../utils';\nimport { AuthContext, AuthProvider } from './auth_provider';\nimport { MongoCredentials } from './mongo_credentials';\nimport { AuthMechanism } from './providers';\n\nconst ASCII_N = 110;\nconst AWS_RELATIVE_URI = 'http://169.254.170.2';\nconst AWS_EC2_URI = 'http://169.254.169.254';\nconst AWS_EC2_PATH = '/latest/meta-data/iam/security-credentials';\nconst bsonOptions: BSONSerializeOptions = {\n  promoteLongs: true,\n  promoteValues: true,\n  promoteBuffers: false,\n  bsonRegExp: false\n};\n\ninterface AWSSaslContinuePayload {\n  a: string;\n  d: string;\n  t?: string;\n}\n\nexport class MongoDBAWS extends AuthProvider {\n  override auth(authContext: AuthContext, callback: Callback): void {\n    const { connection, credentials } = authContext;\n    if (!credentials) {\n      return callback(new MongoMissingCredentialsError('AuthContext must provide credentials.'));\n    }\n\n    if ('kModuleError' in aws4) {\n      return callback(aws4['kModuleError']);\n    }\n    const { sign } = aws4;\n\n    if (maxWireVersion(connection) < 9) {\n      callback(\n        new MongoCompatibilityError(\n          'MONGODB-AWS authentication requires MongoDB version 4.4 or later'\n        )\n      );\n      return;\n    }\n\n    if (!credentials.username) {\n      makeTempCredentials(credentials, (err, tempCredentials) => {\n        if (err || !tempCredentials) return callback(err);\n\n        authContext.credentials = tempCredentials;\n        this.auth(authContext, callback);\n      });\n\n      return;\n    }\n\n    const accessKeyId = credentials.username;\n    const secretAccessKey = credentials.password;\n    const sessionToken = credentials.mechanismProperties.AWS_SESSION_TOKEN;\n\n    // If all three defined, include sessionToken, else include username and pass, else no credentials\n    const awsCredentials =\n      accessKeyId && secretAccessKey && sessionToken\n        ? { accessKeyId, secretAccessKey, sessionToken }\n        : accessKeyId && secretAccessKey\n        ? { accessKeyId, secretAccessKey }\n        : undefined;\n\n    const db = credentials.source;\n    crypto.randomBytes(32, (err, nonce) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      const saslStart = {\n        saslStart: 1,\n        mechanism: 'MONGODB-AWS',\n        payload: BSON.serialize({ r: nonce, p: ASCII_N }, bsonOptions)\n      };\n\n      connection.command(ns(`${db}.$cmd`), saslStart, undefined, (err, res) => {\n        if (err) return callback(err);\n\n        const serverResponse = BSON.deserialize(res.payload.buffer, bsonOptions) as {\n          s: Binary;\n          h: string;\n        };\n        const host = serverResponse.h;\n        const serverNonce = serverResponse.s.buffer;\n        if (serverNonce.length !== 64) {\n          callback(\n            // TODO(NODE-3483)\n            new MongoRuntimeError(`Invalid server nonce length ${serverNonce.length}, expected 64`)\n          );\n\n          return;\n        }\n\n        if (!ByteUtils.equals(serverNonce.subarray(0, nonce.byteLength), nonce)) {\n          // throw because the serverNonce's leading 32 bytes must equal the client nonce's 32 bytes\n          // https://github.com/mongodb/specifications/blob/875446db44aade414011731840831f38a6c668df/source/auth/auth.rst#id11\n\n          // TODO(NODE-3483)\n          callback(new MongoRuntimeError('Server nonce does not begin with client nonce'));\n          return;\n        }\n\n        if (host.length < 1 || host.length > 255 || host.indexOf('..') !== -1) {\n          // TODO(NODE-3483)\n          callback(new MongoRuntimeError(`Server returned an invalid host: \"${host}\"`));\n          return;\n        }\n\n        const body = 'Action=GetCallerIdentity&Version=2011-06-15';\n        const options = sign(\n          {\n            method: 'POST',\n            host,\n            region: deriveRegion(serverResponse.h),\n            service: 'sts',\n            headers: {\n              'Content-Type': 'application/x-www-form-urlencoded',\n              'Content-Length': body.length,\n              'X-MongoDB-Server-Nonce': ByteUtils.toBase64(serverNonce),\n              'X-MongoDB-GS2-CB-Flag': 'n'\n            },\n            path: '/',\n            body\n          },\n          awsCredentials\n        );\n\n        const payload: AWSSaslContinuePayload = {\n          a: options.headers.Authorization,\n          d: options.headers['X-Amz-Date']\n        };\n        if (sessionToken) {\n          payload.t = sessionToken;\n        }\n\n        const saslContinue = {\n          saslContinue: 1,\n          conversationId: 1,\n          payload: BSON.serialize(payload, bsonOptions)\n        };\n\n        connection.command(ns(`${db}.$cmd`), saslContinue, undefined, callback);\n      });\n    });\n  }\n}\n\ninterface AWSTempCredentials {\n  AccessKeyId?: string;\n  SecretAccessKey?: string;\n  Token?: string;\n  RoleArn?: string;\n  Expiration?: Date;\n}\n\n/* @internal */\nexport interface AWSCredentials {\n  accessKeyId?: string;\n  secretAccessKey?: string;\n  sessionToken?: string;\n  expiration?: Date;\n}\n\nfunction makeTempCredentials(credentials: MongoCredentials, callback: Callback<MongoCredentials>) {\n  function done(creds: AWSTempCredentials) {\n    if (!creds.AccessKeyId || !creds.SecretAccessKey || !creds.Token) {\n      callback(\n        new MongoMissingCredentialsError('Could not obtain temporary MONGODB-AWS credentials')\n      );\n      return;\n    }\n\n    callback(\n      undefined,\n      new MongoCredentials({\n        username: creds.AccessKeyId,\n        password: creds.SecretAccessKey,\n        source: credentials.source,\n        mechanism: AuthMechanism.MONGODB_AWS,\n        mechanismProperties: {\n          AWS_SESSION_TOKEN: creds.Token\n        }\n      })\n    );\n  }\n\n  const credentialProvider = getAwsCredentialProvider();\n\n  // Check if the AWS credential provider from the SDK is present. If not,\n  // use the old method.\n  if ('kModuleError' in credentialProvider) {\n    // If the environment variable AWS_CONTAINER_CREDENTIALS_RELATIVE_URI\n    // is set then drivers MUST assume that it was set by an AWS ECS agent\n    if (process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI) {\n      request(\n        `${AWS_RELATIVE_URI}${process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI}`,\n        undefined,\n        (err, res) => {\n          if (err) return callback(err);\n          done(res);\n        }\n      );\n\n      return;\n    }\n\n    // Otherwise assume we are on an EC2 instance\n\n    // get a token\n    request(\n      `${AWS_EC2_URI}/latest/api/token`,\n      { method: 'PUT', json: false, headers: { 'X-aws-ec2-metadata-token-ttl-seconds': 30 } },\n      (err, token) => {\n        if (err) return callback(err);\n\n        // get role name\n        request(\n          `${AWS_EC2_URI}/${AWS_EC2_PATH}`,\n          { json: false, headers: { 'X-aws-ec2-metadata-token': token } },\n          (err, roleName) => {\n            if (err) return callback(err);\n\n            // get temp credentials\n            request(\n              `${AWS_EC2_URI}/${AWS_EC2_PATH}/${roleName}`,\n              { headers: { 'X-aws-ec2-metadata-token': token } },\n              (err, creds) => {\n                if (err) return callback(err);\n                done(creds);\n              }\n            );\n          }\n        );\n      }\n    );\n  } else {\n    /*\n     * Creates a credential provider that will attempt to find credentials from the\n     * following sources (listed in order of precedence):\n     *\n     * - Environment variables exposed via process.env\n     * - SSO credentials from token cache\n     * - Web identity token credentials\n     * - Shared credentials and config ini files\n     * - The EC2/ECS Instance Metadata Service\n     */\n    const { fromNodeProviderChain } = credentialProvider;\n    const provider = fromNodeProviderChain();\n    provider()\n      .then((creds: AWSCredentials) => {\n        done({\n          AccessKeyId: creds.accessKeyId,\n          SecretAccessKey: creds.secretAccessKey,\n          Token: creds.sessionToken,\n          Expiration: creds.expiration\n        });\n      })\n      .catch((error: Error) => {\n        callback(new MongoAWSError(error.message));\n      });\n  }\n}\n\nfunction deriveRegion(host: string) {\n  const parts = host.split('.');\n  if (parts.length === 1 || parts[1] === 'amazonaws') {\n    return 'us-east-1';\n  }\n\n  return parts[1];\n}\n\ninterface RequestOptions {\n  json?: boolean;\n  method?: string;\n  timeout?: number;\n  headers?: http.OutgoingHttpHeaders;\n}\n\nfunction request(uri: string, _options: RequestOptions | undefined, callback: Callback) {\n  const options = Object.assign(\n    {\n      method: 'GET',\n      timeout: 10000,\n      json: true\n    },\n    url.parse(uri),\n    _options\n  );\n\n  const req = http.request(options, res => {\n    res.setEncoding('utf8');\n\n    let data = '';\n    res.on('data', d => (data += d));\n    res.on('end', () => {\n      if (options.json === false) {\n        callback(undefined, data);\n        return;\n      }\n\n      try {\n        const parsed = JSON.parse(data);\n        callback(undefined, parsed);\n      } catch (err) {\n        // TODO(NODE-3483)\n        callback(new MongoRuntimeError(`Invalid JSON response: \"${data}\"`));\n      }\n    });\n  });\n\n  req.on('timeout', () => {\n    req.destroy(new MongoAWSError(`AWS request to ${uri} timed out after ${options.timeout} ms`));\n  });\n\n  req.on('error', err => callback(err));\n  req.end();\n}\n"]},"metadata":{},"sourceType":"script"}