{"ast":null,"code":"import { DEFAULT_RETRY_DELAY_BASE, MAXIMUM_RETRY_DELAY, NO_RETRY_INCREMENT, RETRY_COST, THROTTLING_RETRY_DELAY_BASE, TIMEOUT_RETRY_COST } from \"./constants\";\nimport { getDefaultRetryBackoffStrategy } from \"./defaultRetryBackoffStrategy\";\nexport const getDefaultRetryToken = (initialRetryTokens, initialRetryDelay, initialRetryCount, options) => {\n  const MAX_CAPACITY = initialRetryTokens;\n  const retryCost = options?.retryCost ?? RETRY_COST;\n  const timeoutRetryCost = options?.timeoutRetryCost ?? TIMEOUT_RETRY_COST;\n  const retryBackoffStrategy = options?.retryBackoffStrategy ?? getDefaultRetryBackoffStrategy();\n  let availableCapacity = initialRetryTokens;\n  let retryDelay = Math.min(MAXIMUM_RETRY_DELAY, initialRetryDelay);\n  let lastRetryCost = undefined;\n  let retryCount = initialRetryCount ?? 0;\n\n  const getCapacityAmount = errorType => errorType === \"TRANSIENT\" ? timeoutRetryCost : retryCost;\n\n  const getRetryCount = () => retryCount;\n\n  const getRetryDelay = () => retryDelay;\n\n  const getLastRetryCost = () => lastRetryCost;\n\n  const hasRetryTokens = errorType => getCapacityAmount(errorType) <= availableCapacity;\n\n  const getRetryTokenCount = errorInfo => {\n    const errorType = errorInfo.errorType;\n\n    if (!hasRetryTokens(errorType)) {\n      throw new Error(\"No retry token available\");\n    }\n\n    const capacityAmount = getCapacityAmount(errorType);\n    const delayBase = errorType === \"THROTTLING\" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE;\n    retryBackoffStrategy.setDelayBase(delayBase);\n    const delayFromErrorType = retryBackoffStrategy.computeNextBackoffDelay(retryCount);\n\n    if (errorInfo.retryAfterHint) {\n      const delayFromRetryAfterHint = errorInfo.retryAfterHint.getTime() - Date.now();\n      retryDelay = Math.max(delayFromRetryAfterHint || 0, delayFromErrorType);\n    } else {\n      retryDelay = delayFromErrorType;\n    }\n\n    retryCount++;\n    lastRetryCost = capacityAmount;\n    availableCapacity -= capacityAmount;\n    return capacityAmount;\n  };\n\n  const releaseRetryTokens = releaseAmount => {\n    availableCapacity += releaseAmount ?? NO_RETRY_INCREMENT;\n    availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);\n  };\n\n  return {\n    getRetryCount,\n    getRetryDelay,\n    getLastRetryCost,\n    hasRetryTokens,\n    getRetryTokenCount,\n    releaseRetryTokens\n  };\n};","map":{"version":3,"names":["DEFAULT_RETRY_DELAY_BASE","MAXIMUM_RETRY_DELAY","NO_RETRY_INCREMENT","RETRY_COST","THROTTLING_RETRY_DELAY_BASE","TIMEOUT_RETRY_COST","getDefaultRetryBackoffStrategy","getDefaultRetryToken","initialRetryTokens","initialRetryDelay","initialRetryCount","options","MAX_CAPACITY","retryCost","timeoutRetryCost","retryBackoffStrategy","availableCapacity","retryDelay","Math","min","lastRetryCost","undefined","retryCount","getCapacityAmount","errorType","getRetryCount","getRetryDelay","getLastRetryCost","hasRetryTokens","getRetryTokenCount","errorInfo","Error","capacityAmount","delayBase","setDelayBase","delayFromErrorType","computeNextBackoffDelay","retryAfterHint","delayFromRetryAfterHint","getTime","Date","now","max","releaseRetryTokens","releaseAmount"],"sources":["C:/Users/anshs/OneDrive/Documents/Code/WebDevelopement/portfolioPersonal/node_modules/@aws-sdk/util-retry/dist-es/defaultRetryToken.js"],"sourcesContent":["import { DEFAULT_RETRY_DELAY_BASE, MAXIMUM_RETRY_DELAY, NO_RETRY_INCREMENT, RETRY_COST, THROTTLING_RETRY_DELAY_BASE, TIMEOUT_RETRY_COST, } from \"./constants\";\nimport { getDefaultRetryBackoffStrategy } from \"./defaultRetryBackoffStrategy\";\nexport const getDefaultRetryToken = (initialRetryTokens, initialRetryDelay, initialRetryCount, options) => {\n    const MAX_CAPACITY = initialRetryTokens;\n    const retryCost = options?.retryCost ?? RETRY_COST;\n    const timeoutRetryCost = options?.timeoutRetryCost ?? TIMEOUT_RETRY_COST;\n    const retryBackoffStrategy = options?.retryBackoffStrategy ?? getDefaultRetryBackoffStrategy();\n    let availableCapacity = initialRetryTokens;\n    let retryDelay = Math.min(MAXIMUM_RETRY_DELAY, initialRetryDelay);\n    let lastRetryCost = undefined;\n    let retryCount = initialRetryCount ?? 0;\n    const getCapacityAmount = (errorType) => (errorType === \"TRANSIENT\" ? timeoutRetryCost : retryCost);\n    const getRetryCount = () => retryCount;\n    const getRetryDelay = () => retryDelay;\n    const getLastRetryCost = () => lastRetryCost;\n    const hasRetryTokens = (errorType) => getCapacityAmount(errorType) <= availableCapacity;\n    const getRetryTokenCount = (errorInfo) => {\n        const errorType = errorInfo.errorType;\n        if (!hasRetryTokens(errorType)) {\n            throw new Error(\"No retry token available\");\n        }\n        const capacityAmount = getCapacityAmount(errorType);\n        const delayBase = errorType === \"THROTTLING\" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE;\n        retryBackoffStrategy.setDelayBase(delayBase);\n        const delayFromErrorType = retryBackoffStrategy.computeNextBackoffDelay(retryCount);\n        if (errorInfo.retryAfterHint) {\n            const delayFromRetryAfterHint = errorInfo.retryAfterHint.getTime() - Date.now();\n            retryDelay = Math.max(delayFromRetryAfterHint || 0, delayFromErrorType);\n        }\n        else {\n            retryDelay = delayFromErrorType;\n        }\n        retryCount++;\n        lastRetryCost = capacityAmount;\n        availableCapacity -= capacityAmount;\n        return capacityAmount;\n    };\n    const releaseRetryTokens = (releaseAmount) => {\n        availableCapacity += releaseAmount ?? NO_RETRY_INCREMENT;\n        availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);\n    };\n    return {\n        getRetryCount,\n        getRetryDelay,\n        getLastRetryCost,\n        hasRetryTokens,\n        getRetryTokenCount,\n        releaseRetryTokens,\n    };\n};\n"],"mappings":"AAAA,SAASA,wBAAT,EAAmCC,mBAAnC,EAAwDC,kBAAxD,EAA4EC,UAA5E,EAAwFC,2BAAxF,EAAqHC,kBAArH,QAAgJ,aAAhJ;AACA,SAASC,8BAAT,QAA+C,+BAA/C;AACA,OAAO,MAAMC,oBAAoB,GAAG,CAACC,kBAAD,EAAqBC,iBAArB,EAAwCC,iBAAxC,EAA2DC,OAA3D,KAAuE;EACvG,MAAMC,YAAY,GAAGJ,kBAArB;EACA,MAAMK,SAAS,GAAGF,OAAO,EAAEE,SAAT,IAAsBV,UAAxC;EACA,MAAMW,gBAAgB,GAAGH,OAAO,EAAEG,gBAAT,IAA6BT,kBAAtD;EACA,MAAMU,oBAAoB,GAAGJ,OAAO,EAAEI,oBAAT,IAAiCT,8BAA8B,EAA5F;EACA,IAAIU,iBAAiB,GAAGR,kBAAxB;EACA,IAAIS,UAAU,GAAGC,IAAI,CAACC,GAAL,CAASlB,mBAAT,EAA8BQ,iBAA9B,CAAjB;EACA,IAAIW,aAAa,GAAGC,SAApB;EACA,IAAIC,UAAU,GAAGZ,iBAAiB,IAAI,CAAtC;;EACA,MAAMa,iBAAiB,GAAIC,SAAD,IAAgBA,SAAS,KAAK,WAAd,GAA4BV,gBAA5B,GAA+CD,SAAzF;;EACA,MAAMY,aAAa,GAAG,MAAMH,UAA5B;;EACA,MAAMI,aAAa,GAAG,MAAMT,UAA5B;;EACA,MAAMU,gBAAgB,GAAG,MAAMP,aAA/B;;EACA,MAAMQ,cAAc,GAAIJ,SAAD,IAAeD,iBAAiB,CAACC,SAAD,CAAjB,IAAgCR,iBAAtE;;EACA,MAAMa,kBAAkB,GAAIC,SAAD,IAAe;IACtC,MAAMN,SAAS,GAAGM,SAAS,CAACN,SAA5B;;IACA,IAAI,CAACI,cAAc,CAACJ,SAAD,CAAnB,EAAgC;MAC5B,MAAM,IAAIO,KAAJ,CAAU,0BAAV,CAAN;IACH;;IACD,MAAMC,cAAc,GAAGT,iBAAiB,CAACC,SAAD,CAAxC;IACA,MAAMS,SAAS,GAAGT,SAAS,KAAK,YAAd,GAA6BpB,2BAA7B,GAA2DJ,wBAA7E;IACAe,oBAAoB,CAACmB,YAArB,CAAkCD,SAAlC;IACA,MAAME,kBAAkB,GAAGpB,oBAAoB,CAACqB,uBAArB,CAA6Cd,UAA7C,CAA3B;;IACA,IAAIQ,SAAS,CAACO,cAAd,EAA8B;MAC1B,MAAMC,uBAAuB,GAAGR,SAAS,CAACO,cAAV,CAAyBE,OAAzB,KAAqCC,IAAI,CAACC,GAAL,EAArE;MACAxB,UAAU,GAAGC,IAAI,CAACwB,GAAL,CAASJ,uBAAuB,IAAI,CAApC,EAAuCH,kBAAvC,CAAb;IACH,CAHD,MAIK;MACDlB,UAAU,GAAGkB,kBAAb;IACH;;IACDb,UAAU;IACVF,aAAa,GAAGY,cAAhB;IACAhB,iBAAiB,IAAIgB,cAArB;IACA,OAAOA,cAAP;EACH,CApBD;;EAqBA,MAAMW,kBAAkB,GAAIC,aAAD,IAAmB;IAC1C5B,iBAAiB,IAAI4B,aAAa,IAAI1C,kBAAtC;IACAc,iBAAiB,GAAGE,IAAI,CAACC,GAAL,CAASH,iBAAT,EAA4BJ,YAA5B,CAApB;EACH,CAHD;;EAIA,OAAO;IACHa,aADG;IAEHC,aAFG;IAGHC,gBAHG;IAIHC,cAJG;IAKHC,kBALG;IAMHc;EANG,CAAP;AAQH,CA/CM"},"metadata":{},"sourceType":"module"}