{"ast":null,"code":"import { isThrottlingError } from \"@aws-sdk/service-error-classification\";\nexport class DefaultRateLimiter {\n  constructor(options) {\n    this.currentCapacity = 0;\n    this.enabled = false;\n    this.lastMaxRate = 0;\n    this.measuredTxRate = 0;\n    this.requestCount = 0;\n    this.lastTimestamp = 0;\n    this.timeWindow = 0;\n    this.beta = options?.beta ?? 0.7;\n    this.minCapacity = options?.minCapacity ?? 1;\n    this.minFillRate = options?.minFillRate ?? 0.5;\n    this.scaleConstant = options?.scaleConstant ?? 0.4;\n    this.smooth = options?.smooth ?? 0.8;\n    const currentTimeInSeconds = this.getCurrentTimeInSeconds();\n    this.lastThrottleTime = currentTimeInSeconds;\n    this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());\n    this.fillRate = this.minFillRate;\n    this.maxCapacity = this.minCapacity;\n  }\n\n  getCurrentTimeInSeconds() {\n    return Date.now() / 1000;\n  }\n\n  async getSendToken() {\n    return this.acquireTokenBucket(1);\n  }\n\n  async acquireTokenBucket(amount) {\n    if (!this.enabled) {\n      return;\n    }\n\n    this.refillTokenBucket();\n\n    if (amount > this.currentCapacity) {\n      const delay = (amount - this.currentCapacity) / this.fillRate * 1000;\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n\n    this.currentCapacity = this.currentCapacity - amount;\n  }\n\n  refillTokenBucket() {\n    const timestamp = this.getCurrentTimeInSeconds();\n\n    if (!this.lastTimestamp) {\n      this.lastTimestamp = timestamp;\n      return;\n    }\n\n    const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;\n    this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);\n    this.lastTimestamp = timestamp;\n  }\n\n  updateClientSendingRate(response) {\n    let calculatedRate;\n    this.updateMeasuredRate();\n\n    if (isThrottlingError(response)) {\n      const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);\n      this.lastMaxRate = rateToUse;\n      this.calculateTimeWindow();\n      this.lastThrottleTime = this.getCurrentTimeInSeconds();\n      calculatedRate = this.cubicThrottle(rateToUse);\n      this.enableTokenBucket();\n    } else {\n      this.calculateTimeWindow();\n      calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());\n    }\n\n    const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);\n    this.updateTokenBucketRate(newRate);\n  }\n\n  calculateTimeWindow() {\n    this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));\n  }\n\n  cubicThrottle(rateToUse) {\n    return this.getPrecise(rateToUse * this.beta);\n  }\n\n  cubicSuccess(timestamp) {\n    return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);\n  }\n\n  enableTokenBucket() {\n    this.enabled = true;\n  }\n\n  updateTokenBucketRate(newRate) {\n    this.refillTokenBucket();\n    this.fillRate = Math.max(newRate, this.minFillRate);\n    this.maxCapacity = Math.max(newRate, this.minCapacity);\n    this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);\n  }\n\n  updateMeasuredRate() {\n    const t = this.getCurrentTimeInSeconds();\n    const timeBucket = Math.floor(t * 2) / 2;\n    this.requestCount++;\n\n    if (timeBucket > this.lastTxRateBucket) {\n      const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);\n      this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));\n      this.requestCount = 0;\n      this.lastTxRateBucket = timeBucket;\n    }\n  }\n\n  getPrecise(num) {\n    return parseFloat(num.toFixed(8));\n  }\n\n}","map":{"version":3,"names":["isThrottlingError","DefaultRateLimiter","constructor","options","currentCapacity","enabled","lastMaxRate","measuredTxRate","requestCount","lastTimestamp","timeWindow","beta","minCapacity","minFillRate","scaleConstant","smooth","currentTimeInSeconds","getCurrentTimeInSeconds","lastThrottleTime","lastTxRateBucket","Math","floor","fillRate","maxCapacity","Date","now","getSendToken","acquireTokenBucket","amount","refillTokenBucket","delay","Promise","resolve","setTimeout","timestamp","fillAmount","min","updateClientSendingRate","response","calculatedRate","updateMeasuredRate","rateToUse","calculateTimeWindow","cubicThrottle","enableTokenBucket","cubicSuccess","newRate","updateTokenBucketRate","getPrecise","pow","max","t","timeBucket","currentRate","num","parseFloat","toFixed"],"sources":["C:/Users/anshs/OneDrive/Documents/Code/WebDevelopement/portfolioPersonal/node_modules/@aws-sdk/util-retry/dist-es/DefaultRateLimiter.js"],"sourcesContent":["import { isThrottlingError } from \"@aws-sdk/service-error-classification\";\nexport class DefaultRateLimiter {\n    constructor(options) {\n        this.currentCapacity = 0;\n        this.enabled = false;\n        this.lastMaxRate = 0;\n        this.measuredTxRate = 0;\n        this.requestCount = 0;\n        this.lastTimestamp = 0;\n        this.timeWindow = 0;\n        this.beta = options?.beta ?? 0.7;\n        this.minCapacity = options?.minCapacity ?? 1;\n        this.minFillRate = options?.minFillRate ?? 0.5;\n        this.scaleConstant = options?.scaleConstant ?? 0.4;\n        this.smooth = options?.smooth ?? 0.8;\n        const currentTimeInSeconds = this.getCurrentTimeInSeconds();\n        this.lastThrottleTime = currentTimeInSeconds;\n        this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());\n        this.fillRate = this.minFillRate;\n        this.maxCapacity = this.minCapacity;\n    }\n    getCurrentTimeInSeconds() {\n        return Date.now() / 1000;\n    }\n    async getSendToken() {\n        return this.acquireTokenBucket(1);\n    }\n    async acquireTokenBucket(amount) {\n        if (!this.enabled) {\n            return;\n        }\n        this.refillTokenBucket();\n        if (amount > this.currentCapacity) {\n            const delay = ((amount - this.currentCapacity) / this.fillRate) * 1000;\n            await new Promise((resolve) => setTimeout(resolve, delay));\n        }\n        this.currentCapacity = this.currentCapacity - amount;\n    }\n    refillTokenBucket() {\n        const timestamp = this.getCurrentTimeInSeconds();\n        if (!this.lastTimestamp) {\n            this.lastTimestamp = timestamp;\n            return;\n        }\n        const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;\n        this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);\n        this.lastTimestamp = timestamp;\n    }\n    updateClientSendingRate(response) {\n        let calculatedRate;\n        this.updateMeasuredRate();\n        if (isThrottlingError(response)) {\n            const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);\n            this.lastMaxRate = rateToUse;\n            this.calculateTimeWindow();\n            this.lastThrottleTime = this.getCurrentTimeInSeconds();\n            calculatedRate = this.cubicThrottle(rateToUse);\n            this.enableTokenBucket();\n        }\n        else {\n            this.calculateTimeWindow();\n            calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());\n        }\n        const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);\n        this.updateTokenBucketRate(newRate);\n    }\n    calculateTimeWindow() {\n        this.timeWindow = this.getPrecise(Math.pow((this.lastMaxRate * (1 - this.beta)) / this.scaleConstant, 1 / 3));\n    }\n    cubicThrottle(rateToUse) {\n        return this.getPrecise(rateToUse * this.beta);\n    }\n    cubicSuccess(timestamp) {\n        return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);\n    }\n    enableTokenBucket() {\n        this.enabled = true;\n    }\n    updateTokenBucketRate(newRate) {\n        this.refillTokenBucket();\n        this.fillRate = Math.max(newRate, this.minFillRate);\n        this.maxCapacity = Math.max(newRate, this.minCapacity);\n        this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);\n    }\n    updateMeasuredRate() {\n        const t = this.getCurrentTimeInSeconds();\n        const timeBucket = Math.floor(t * 2) / 2;\n        this.requestCount++;\n        if (timeBucket > this.lastTxRateBucket) {\n            const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);\n            this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));\n            this.requestCount = 0;\n            this.lastTxRateBucket = timeBucket;\n        }\n    }\n    getPrecise(num) {\n        return parseFloat(num.toFixed(8));\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}