{"ast":null,"code":"const EOL = \"\\n\";\n/**\n * \n * @param {array} jArray \n * @param {any} options \n * @returns \n */\n\nfunction toXml(jArray, options) {\n  return arrToStr(jArray, options, \"\", 0);\n}\n\nfunction arrToStr(arr, options, jPath, level) {\n  let xmlStr = \"\";\n  let indentation = \"\";\n\n  if (options.format && options.indentBy.length > 0) {\n    //TODO: this logic can be avoided for each call\n    indentation = EOL + \"\" + options.indentBy.repeat(level);\n  }\n\n  for (let i = 0; i < arr.length; i++) {\n    const tagObj = arr[i];\n    const tagName = propName(tagObj);\n    let newJPath = \"\";\n    if (jPath.length === 0) newJPath = tagName;else newJPath = `${jPath}.${tagName}`;\n\n    if (tagName === options.textNodeName) {\n      let tagText = tagObj[tagName];\n\n      if (!isStopNode(newJPath, options)) {\n        tagText = options.tagValueProcessor(tagName, tagText);\n        tagText = replaceEntitiesValue(tagText, options);\n      }\n\n      xmlStr += indentation + tagText;\n      continue;\n    } else if (tagName === options.cdataPropName) {\n      xmlStr += indentation + `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;\n      continue;\n    } else if (tagName === options.commentPropName) {\n      xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;\n      continue;\n    } else if (tagName[0] === \"?\") {\n      const attStr = attr_to_str(tagObj[\":@\"], options);\n      const tempInd = tagName === \"?xml\" ? \"\" : indentation;\n      let piTextNodeName = tagObj[tagName][0][options.textNodeName];\n      piTextNodeName = piTextNodeName.length !== 0 ? \" \" + piTextNodeName : \"\"; //remove extra spacing\n\n      xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;\n      continue;\n    }\n\n    const attStr = attr_to_str(tagObj[\":@\"], options);\n    let tagStart = indentation + `<${tagName}${attStr}`;\n    let tagValue = arrToStr(tagObj[tagName], options, newJPath, level + 1);\n\n    if (options.unpairedTags.indexOf(tagName) !== -1) {\n      if (options.suppressUnpairedNode) xmlStr += tagStart + \">\";else xmlStr += tagStart + \"/>\";\n    } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {\n      xmlStr += tagStart + \"/>\";\n    } else {\n      //TODO: node with only text value should not parse the text value in next line\n      xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;\n    }\n  }\n\n  return xmlStr;\n}\n\nfunction propName(obj) {\n  const keys = Object.keys(obj);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (key !== \":@\") return key;\n  }\n}\n\nfunction attr_to_str(attrMap, options) {\n  let attrStr = \"\";\n\n  if (attrMap && !options.ignoreAttributes) {\n    for (let attr in attrMap) {\n      let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);\n      attrVal = replaceEntitiesValue(attrVal, options);\n\n      if (attrVal === true && options.suppressBooleanAttributes) {\n        attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;\n      } else {\n        attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}=\"${attrVal}\"`;\n      }\n    }\n  }\n\n  return attrStr;\n}\n\nfunction isStopNode(jPath, options) {\n  jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);\n  let tagName = jPath.substr(jPath.lastIndexOf(\".\") + 1);\n\n  for (let index in options.stopNodes) {\n    if (options.stopNodes[index] === jPath || options.stopNodes[index] === \"*.\" + tagName) return true;\n  }\n\n  return false;\n}\n\nfunction replaceEntitiesValue(textValue, options) {\n  if (textValue && textValue.length > 0 && options.processEntities) {\n    for (let i = 0; i < options.entities.length; i++) {\n      const entity = options.entities[i];\n      textValue = textValue.replace(entity.regex, entity.val);\n    }\n  }\n\n  return textValue;\n}\n\nmodule.exports = toXml;","map":{"version":3,"names":["EOL","toXml","jArray","options","arrToStr","arr","jPath","level","xmlStr","indentation","format","indentBy","length","repeat","i","tagObj","tagName","propName","newJPath","textNodeName","tagText","isStopNode","tagValueProcessor","replaceEntitiesValue","cdataPropName","commentPropName","attStr","attr_to_str","tempInd","piTextNodeName","tagStart","tagValue","unpairedTags","indexOf","suppressUnpairedNode","suppressEmptyNode","obj","keys","Object","key","attrMap","attrStr","ignoreAttributes","attr","attrVal","attributeValueProcessor","suppressBooleanAttributes","substr","attributeNamePrefix","lastIndexOf","index","stopNodes","textValue","processEntities","entities","entity","replace","regex","val","module","exports"],"sources":["C:/Users/anshs/OneDrive/Documents/Code/WebDevelopement/portfolioPersonal/node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"],"sourcesContent":["const EOL = \"\\n\";\n\n/**\n * \n * @param {array} jArray \n * @param {any} options \n * @returns \n */\nfunction toXml(jArray, options){\n    return arrToStr( jArray, options, \"\", 0);\n}\n\nfunction arrToStr(arr, options, jPath, level){\n    let xmlStr = \"\";\n\n    let indentation = \"\";\n    if(options.format && options.indentBy.length > 0){//TODO: this logic can be avoided for each call\n        indentation = EOL + \"\" + options.indentBy.repeat(level);\n    }\n\n    for (let i = 0; i < arr.length; i++) {\n        const tagObj = arr[i];\n        const tagName = propName(tagObj);\n        let newJPath = \"\";\n        if(jPath.length === 0) newJPath = tagName\n        else newJPath = `${jPath}.${tagName}`;\n\n        if(tagName === options.textNodeName){\n            let tagText = tagObj[tagName];\n            if(!isStopNode(newJPath, options)){\n                tagText = options.tagValueProcessor( tagName, tagText);\n                tagText = replaceEntitiesValue(tagText, options);\n            }\n            xmlStr += indentation + tagText;\n            continue;\n        }else if( tagName === options.cdataPropName){\n            xmlStr += indentation + `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;\n            continue;\n        }else if( tagName === options.commentPropName){\n            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;\n            continue;\n        }else if( tagName[0] === \"?\"){\n            const attStr = attr_to_str(tagObj[\":@\"], options);\n            const tempInd = tagName === \"?xml\" ? \"\" : indentation;\n            let piTextNodeName = tagObj[tagName][0][options.textNodeName];\n            piTextNodeName = piTextNodeName.length !== 0 ? \" \" + piTextNodeName : \"\"; //remove extra spacing\n            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;\n            continue;\n        }\n        const attStr = attr_to_str(tagObj[\":@\"], options);\n        let tagStart =  indentation + `<${tagName}${attStr}`;\n        let tagValue = arrToStr(tagObj[tagName], options, newJPath, level + 1);\n        if(options.unpairedTags.indexOf(tagName) !== -1){\n            if(options.suppressUnpairedNode)  xmlStr += tagStart + \">\"; \n            else xmlStr += tagStart + \"/>\"; \n        }else if( (!tagValue || tagValue.length === 0) && options.suppressEmptyNode){ \n            xmlStr += tagStart + \"/>\"; \n        }else{ \n            //TODO: node with only text value should not parse the text value in next line\n            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>` ;\n        }\n    }\n    \n    return xmlStr;\n}\n\nfunction propName(obj){\n    const keys = Object.keys(obj);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if(key !== \":@\") return key;\n    }\n  }\n\nfunction attr_to_str(attrMap, options){\n    let attrStr = \"\";\n    if(attrMap && !options.ignoreAttributes){\n        for (let attr in attrMap){\n            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);\n            attrVal = replaceEntitiesValue(attrVal, options);\n            if(attrVal === true && options.suppressBooleanAttributes){\n                attrStr+= ` ${attr.substr(options.attributeNamePrefix.length)}`;\n            }else{\n                attrStr+= ` ${attr.substr(options.attributeNamePrefix.length)}=\"${attrVal}\"`;\n            }\n        }\n    }\n    return attrStr;\n}\n\nfunction isStopNode(jPath, options){\n    jPath = jPath.substr(0,jPath.length - options.textNodeName.length - 1);\n    let tagName = jPath.substr(jPath.lastIndexOf(\".\") + 1);\n    for(let index in options.stopNodes){\n        if(options.stopNodes[index] === jPath || options.stopNodes[index] === \"*.\"+tagName) return true;\n    }\n    return false;\n}\n\nfunction replaceEntitiesValue(textValue, options){\n    if(textValue && textValue.length > 0 && options.processEntities){\n      for (let i=0; i< options.entities.length; i++) {\n        const entity = options.entities[i];\n        textValue = textValue.replace(entity.regex, entity.val);\n      }\n    }\n    return textValue;\n  }\nmodule.exports = toXml;"],"mappings":"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"},"metadata":{},"sourceType":"script"}