{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CancellationToken = exports.TypedEventEmitter = void 0;\n\nconst events_1 = require(\"events\");\n/**\n * Typescript type safe event emitter\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nclass TypedEventEmitter extends events_1.EventEmitter {}\n\nexports.TypedEventEmitter = TypedEventEmitter;\n/** @public */\n\nclass CancellationToken extends TypedEventEmitter {}\n\nexports.CancellationToken = CancellationToken;","map":{"version":3,"mappings":";;;;;;;AACA;AA0YA;;;;AAIA;;;AACA,MAAaA,iBAAb,SAAyEC,qBAAzE,CAAqF;;AAArFC;AAEA;;AACA,MAAaC,iBAAb,SAAuCH,iBAAvC,CAA4E;;AAA5EE","names":["TypedEventEmitter","events_1","exports","CancellationToken"],"sources":["C:\\Users\\anshs\\OneDrive\\Documents\\Code\\WebDevelopement\\portfolioPersonal\\node_modules\\mongodb\\src\\mongo_types.ts"],"sourcesContent":["import type { BSONType, ObjectIdLike } from 'bson';\nimport { EventEmitter } from 'events';\n\nimport type {\n  Binary,\n  BSONRegExp,\n  Decimal128,\n  Document,\n  Double,\n  Int32,\n  Long,\n  ObjectId,\n  Timestamp\n} from './bson';\nimport type { Sort } from './sort';\n\n/** @internal */\nexport type TODO_NODE_3286 = any;\n\n/** Given an object shaped type, return the type of the _id field or default to ObjectId @public */\nexport type InferIdType<TSchema> = TSchema extends { _id: infer IdType }\n  ? // user has defined a type for _id\n    Record<any, never> extends IdType\n    ? never // explicitly forbid empty objects as the type of _id\n    : IdType\n  : TSchema extends { _id?: infer IdType }\n  ? // optional _id defined - return ObjectId | IdType\n    unknown extends IdType\n    ? ObjectId // infer the _id type as ObjectId if the type of _id is unknown\n    : IdType\n  : ObjectId; // user has not defined _id on schema\n\n/** Add an _id field to an object shaped type @public */\nexport type WithId<TSchema> = EnhancedOmit<TSchema, '_id'> & { _id: InferIdType<TSchema> };\n\n/**\n * Add an optional _id field to an object shaped type\n * @public\n */\nexport type OptionalId<TSchema> = EnhancedOmit<TSchema, '_id'> & { _id?: InferIdType<TSchema> };\n\n/**\n * Adds an optional _id field to an object shaped type, unless the _id field is required on that type.\n * In the case _id is required, this method continues to require_id.\n *\n * @public\n *\n * @privateRemarks\n * `ObjectId extends TSchema['_id']` is a confusing ordering at first glance. Rather than ask\n * `TSchema['_id'] extends ObjectId` which translated to \"Is the _id property ObjectId?\"\n * we instead ask \"Does ObjectId look like (have the same shape) as the _id?\"\n */\nexport type OptionalUnlessRequiredId<TSchema> = TSchema extends { _id: any }\n  ? TSchema\n  : OptionalId<TSchema>;\n\n/** TypeScript Omit (Exclude to be specific) does not work for objects with an \"any\" indexed type, and breaks discriminated unions @public */\nexport type EnhancedOmit<TRecordOrUnion, KeyUnion> = string extends keyof TRecordOrUnion\n  ? TRecordOrUnion // TRecordOrUnion has indexed type e.g. { _id: string; [k: string]: any; } or it is \"any\"\n  : TRecordOrUnion extends any\n  ? Pick<TRecordOrUnion, Exclude<keyof TRecordOrUnion, KeyUnion>> // discriminated unions\n  : never;\n\n/** Remove the _id field from an object shaped type @public */\nexport type WithoutId<TSchema> = Omit<TSchema, '_id'>;\n\n/** A MongoDB filter can be some portion of the schema or a set of operators @public */\nexport type Filter<TSchema> = {\n  [P in keyof WithId<TSchema>]?: Condition<WithId<TSchema>[P]>;\n} & RootFilterOperators<WithId<TSchema>>;\n\n/** @public */\nexport type Condition<T> = AlternativeType<T> | FilterOperators<AlternativeType<T>>;\n\n/**\n * It is possible to search using alternative types in mongodb e.g.\n * string types can be searched using a regex in mongo\n * array types can be searched using their element type\n * @public\n */\nexport type AlternativeType<T> = T extends ReadonlyArray<infer U>\n  ? T | RegExpOrString<U>\n  : RegExpOrString<T>;\n\n/** @public */\nexport type RegExpOrString<T> = T extends string ? BSONRegExp | RegExp | T : T;\n\n/** @public */\nexport interface RootFilterOperators<TSchema> extends Document {\n  $and?: Filter<TSchema>[];\n  $nor?: Filter<TSchema>[];\n  $or?: Filter<TSchema>[];\n  $text?: {\n    $search: string;\n    $language?: string;\n    $caseSensitive?: boolean;\n    $diacriticSensitive?: boolean;\n  };\n  $where?: string | ((this: TSchema) => boolean);\n  $comment?: string | Document;\n}\n\n/**\n * @public\n * A type that extends Document but forbids anything that \"looks like\" an object id.\n */\nexport type NonObjectIdLikeDocument = {\n  [key in keyof ObjectIdLike]?: never;\n} & Document;\n\n/** @public */\nexport interface FilterOperators<TValue> extends NonObjectIdLikeDocument {\n  // Comparison\n  $eq?: TValue;\n  $gt?: TValue;\n  $gte?: TValue;\n  $in?: ReadonlyArray<TValue>;\n  $lt?: TValue;\n  $lte?: TValue;\n  $ne?: TValue;\n  $nin?: ReadonlyArray<TValue>;\n  // Logical\n  $not?: TValue extends string ? FilterOperators<TValue> | RegExp : FilterOperators<TValue>;\n  // Element\n  /**\n   * When `true`, `$exists` matches the documents that contain the field,\n   * including documents where the field value is null.\n   */\n  $exists?: boolean;\n  $type?: BSONType | BSONTypeAlias;\n  // Evaluation\n  $expr?: Record<string, any>;\n  $jsonSchema?: Record<string, any>;\n  $mod?: TValue extends number ? [number, number] : never;\n  $regex?: TValue extends string ? RegExp | BSONRegExp | string : never;\n  $options?: TValue extends string ? string : never;\n  // Geospatial\n  $geoIntersects?: { $geometry: Document };\n  $geoWithin?: Document;\n  $near?: Document;\n  $nearSphere?: Document;\n  $maxDistance?: number;\n  // Array\n  $all?: ReadonlyArray<any>;\n  $elemMatch?: Document;\n  $size?: TValue extends ReadonlyArray<any> ? number : never;\n  // Bitwise\n  $bitsAllClear?: BitwiseFilter;\n  $bitsAllSet?: BitwiseFilter;\n  $bitsAnyClear?: BitwiseFilter;\n  $bitsAnySet?: BitwiseFilter;\n  $rand?: Record<string, never>;\n}\n\n/** @public */\nexport type BitwiseFilter =\n  | number /** numeric bit mask */\n  | Binary /** BinData bit mask */\n  | ReadonlyArray<number>; /** `[ <position1>, <position2>, ... ]` */\n\n/** @public */\nexport type BSONTypeAlias = keyof typeof BSONType;\n\n/** @public */\nexport type IsAny<Type, ResultIfAny, ResultIfNotAny> = true extends false & Type\n  ? ResultIfAny\n  : ResultIfNotAny;\n\n/** @public */\nexport type Flatten<Type> = Type extends ReadonlyArray<infer Item> ? Item : Type;\n\n/** @public */\nexport type ArrayElement<Type> = Type extends ReadonlyArray<infer Item> ? Item : never;\n\n/** @public */\nexport type SchemaMember<T, V> = { [P in keyof T]?: V } | { [key: string]: V };\n\n/** @public */\nexport type IntegerType = number | Int32 | Long;\n\n/** @public */\nexport type NumericType = IntegerType | Decimal128 | Double;\n\n/** @public */\nexport type FilterOperations<T> = T extends Record<string, any>\n  ? { [key in keyof T]?: FilterOperators<T[key]> }\n  : FilterOperators<T>;\n\n/** @public */\nexport type KeysOfAType<TSchema, Type> = {\n  [key in keyof TSchema]: NonNullable<TSchema[key]> extends Type ? key : never;\n}[keyof TSchema];\n\n/** @public */\nexport type KeysOfOtherType<TSchema, Type> = {\n  [key in keyof TSchema]: NonNullable<TSchema[key]> extends Type ? never : key;\n}[keyof TSchema];\n\n/** @public */\nexport type AcceptedFields<TSchema, FieldType, AssignableType> = {\n  readonly [key in KeysOfAType<TSchema, FieldType>]?: AssignableType;\n};\n\n/** It avoids using fields with not acceptable types @public */\nexport type NotAcceptedFields<TSchema, FieldType> = {\n  readonly [key in KeysOfOtherType<TSchema, FieldType>]?: never;\n};\n\n/** @public */\nexport type OnlyFieldsOfType<TSchema, FieldType = any, AssignableType = FieldType> = IsAny<\n  TSchema[keyof TSchema],\n  Record<string, FieldType>,\n  AcceptedFields<TSchema, FieldType, AssignableType> &\n    NotAcceptedFields<TSchema, FieldType> &\n    Record<string, AssignableType>\n>;\n\n/** @public */\nexport type MatchKeysAndValues<TSchema> = Readonly<Partial<TSchema>> & Record<string, any>;\n\n/** @public */\nexport type AddToSetOperators<Type> = {\n  $each?: Array<Flatten<Type>>;\n};\n\n/** @public */\nexport type ArrayOperator<Type> = {\n  $each?: Array<Flatten<Type>>;\n  $slice?: number;\n  $position?: number;\n  $sort?: Sort;\n};\n\n/** @public */\nexport type SetFields<TSchema> = ({\n  readonly [key in KeysOfAType<TSchema, ReadonlyArray<any> | undefined>]?:\n    | OptionalId<Flatten<TSchema[key]>>\n    | AddToSetOperators<Array<OptionalId<Flatten<TSchema[key]>>>>;\n} & NotAcceptedFields<TSchema, ReadonlyArray<any> | undefined>) & {\n  readonly [key: string]: AddToSetOperators<any> | any;\n};\n\n/** @public */\nexport type PushOperator<TSchema> = ({\n  readonly [key in KeysOfAType<TSchema, ReadonlyArray<any>>]?:\n    | Flatten<TSchema[key]>\n    | ArrayOperator<Array<Flatten<TSchema[key]>>>;\n} & NotAcceptedFields<TSchema, ReadonlyArray<any>>) & {\n  readonly [key: string]: ArrayOperator<any> | any;\n};\n\n/** @public */\nexport type PullOperator<TSchema> = ({\n  readonly [key in KeysOfAType<TSchema, ReadonlyArray<any>>]?:\n    | Partial<Flatten<TSchema[key]>>\n    | FilterOperations<Flatten<TSchema[key]>>;\n} & NotAcceptedFields<TSchema, ReadonlyArray<any>>) & {\n  readonly [key: string]: FilterOperators<any> | any;\n};\n\n/** @public */\nexport type PullAllOperator<TSchema> = ({\n  readonly [key in KeysOfAType<TSchema, ReadonlyArray<any>>]?: TSchema[key];\n} & NotAcceptedFields<TSchema, ReadonlyArray<any>>) & {\n  readonly [key: string]: ReadonlyArray<any>;\n};\n\n/** @public */\nexport type UpdateFilter<TSchema> = {\n  $currentDate?: OnlyFieldsOfType<\n    TSchema,\n    Date | Timestamp,\n    true | { $type: 'date' | 'timestamp' }\n  >;\n  $inc?: OnlyFieldsOfType<TSchema, NumericType | undefined>;\n  $min?: MatchKeysAndValues<TSchema>;\n  $max?: MatchKeysAndValues<TSchema>;\n  $mul?: OnlyFieldsOfType<TSchema, NumericType | undefined>;\n  $rename?: Record<string, string>;\n  $set?: MatchKeysAndValues<TSchema>;\n  $setOnInsert?: MatchKeysAndValues<TSchema>;\n  $unset?: OnlyFieldsOfType<TSchema, any, '' | true | 1>;\n  $addToSet?: SetFields<TSchema>;\n  $pop?: OnlyFieldsOfType<TSchema, ReadonlyArray<any>, 1 | -1>;\n  $pull?: PullOperator<TSchema>;\n  $push?: PushOperator<TSchema>;\n  $pullAll?: PullAllOperator<TSchema>;\n  $bit?: OnlyFieldsOfType<\n    TSchema,\n    NumericType | undefined,\n    { and: IntegerType } | { or: IntegerType } | { xor: IntegerType }\n  >;\n} & Document;\n\n/** @public */\nexport type Nullable<AnyType> = AnyType | null | undefined;\n\n/** @public */\nexport type OneOrMore<T> = T | ReadonlyArray<T>;\n\n/** @public */\nexport type GenericListener = (...args: any[]) => void;\n\n/**\n * Event description type\n * @public\n */\nexport type EventsDescription = Record<string, GenericListener>;\n\n/** @public */\nexport type CommonEvents = 'newListener' | 'removeListener';\n\n/**\n * Typescript type safe event emitter\n * @public\n */\nexport declare interface TypedEventEmitter<Events extends EventsDescription> extends EventEmitter {\n  addListener<EventKey extends keyof Events>(event: EventKey, listener: Events[EventKey]): this;\n  addListener(\n    event: CommonEvents,\n    listener: (eventName: string | symbol, listener: GenericListener) => void\n  ): this;\n  addListener(event: string | symbol, listener: GenericListener): this;\n\n  on<EventKey extends keyof Events>(event: EventKey, listener: Events[EventKey]): this;\n  on(\n    event: CommonEvents,\n    listener: (eventName: string | symbol, listener: GenericListener) => void\n  ): this;\n  on(event: string | symbol, listener: GenericListener): this;\n\n  once<EventKey extends keyof Events>(event: EventKey, listener: Events[EventKey]): this;\n  once(\n    event: CommonEvents,\n    listener: (eventName: string | symbol, listener: GenericListener) => void\n  ): this;\n  once(event: string | symbol, listener: GenericListener): this;\n\n  removeListener<EventKey extends keyof Events>(event: EventKey, listener: Events[EventKey]): this;\n  removeListener(\n    event: CommonEvents,\n    listener: (eventName: string | symbol, listener: GenericListener) => void\n  ): this;\n  removeListener(event: string | symbol, listener: GenericListener): this;\n\n  off<EventKey extends keyof Events>(event: EventKey, listener: Events[EventKey]): this;\n  off(\n    event: CommonEvents,\n    listener: (eventName: string | symbol, listener: GenericListener) => void\n  ): this;\n  off(event: string | symbol, listener: GenericListener): this;\n\n  removeAllListeners<EventKey extends keyof Events>(\n    event?: EventKey | CommonEvents | symbol | string\n  ): this;\n\n  listeners<EventKey extends keyof Events>(\n    event: EventKey | CommonEvents | symbol | string\n  ): Events[EventKey][];\n\n  rawListeners<EventKey extends keyof Events>(\n    event: EventKey | CommonEvents | symbol | string\n  ): Events[EventKey][];\n\n  emit<EventKey extends keyof Events>(\n    event: EventKey | symbol,\n    ...args: Parameters<Events[EventKey]>\n  ): boolean;\n\n  listenerCount<EventKey extends keyof Events>(\n    type: EventKey | CommonEvents | symbol | string\n  ): number;\n\n  prependListener<EventKey extends keyof Events>(event: EventKey, listener: Events[EventKey]): this;\n  prependListener(\n    event: CommonEvents,\n    listener: (eventName: string | symbol, listener: GenericListener) => void\n  ): this;\n  prependListener(event: string | symbol, listener: GenericListener): this;\n\n  prependOnceListener<EventKey extends keyof Events>(\n    event: EventKey,\n    listener: Events[EventKey]\n  ): this;\n  prependOnceListener(\n    event: CommonEvents,\n    listener: (eventName: string | symbol, listener: GenericListener) => void\n  ): this;\n  prependOnceListener(event: string | symbol, listener: GenericListener): this;\n\n  eventNames(): string[];\n  getMaxListeners(): number;\n  setMaxListeners(n: number): this;\n}\n\n/**\n * Typescript type safe event emitter\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport class TypedEventEmitter<Events extends EventsDescription> extends EventEmitter {}\n\n/** @public */\nexport class CancellationToken extends TypedEventEmitter<{ cancel(): void }> {}\n\n/**\n * Helper types for dot-notation filter attributes\n */\n\n/** @public */\nexport type Join<T extends unknown[], D extends string> = T extends []\n  ? ''\n  : T extends [string | number]\n  ? `${T[0]}`\n  : T extends [string | number, ...infer R]\n  ? `${T[0]}${D}${Join<R, D>}`\n  : string;\n\n/** @public */\nexport type PropertyType<Type, Property extends string> = string extends Property\n  ? unknown\n  : Property extends keyof Type\n  ? Type[Property]\n  : Property extends `${number}`\n  ? Type extends ReadonlyArray<infer ArrayType>\n    ? ArrayType\n    : unknown\n  : Property extends `${infer Key}.${infer Rest}`\n  ? Key extends `${number}`\n    ? Type extends ReadonlyArray<infer ArrayType>\n      ? PropertyType<ArrayType, Rest>\n      : unknown\n    : Key extends keyof Type\n    ? Type[Key] extends Map<string, infer MapType>\n      ? MapType\n      : PropertyType<Type[Key], Rest>\n    : unknown\n  : unknown;\n\n/**\n * @public\n * returns tuple of strings (keys to be joined on '.') that represent every path into a schema\n * https://docs.mongodb.com/manual/tutorial/query-embedded-documents/\n *\n * @remarks\n * Through testing we determined that a depth of 8 is safe for the typescript compiler\n * and provides reasonable compilation times. This number is otherwise not special and\n * should be changed if issues are found with this level of checking. Beyond this\n * depth any helpers that make use of NestedPaths should devolve to not asserting any\n * type safety on the input.\n */\nexport type NestedPaths<Type, Depth extends number[]> = Depth['length'] extends 8\n  ? []\n  : Type extends\n      | string\n      | number\n      | boolean\n      | Date\n      | RegExp\n      | Buffer\n      | Uint8Array\n      | ((...args: any[]) => any)\n      | { _bsontype: string }\n  ? []\n  : Type extends ReadonlyArray<infer ArrayType>\n  ? [] | [number, ...NestedPaths<ArrayType, [...Depth, 1]>]\n  : Type extends Map<string, any>\n  ? [string]\n  : Type extends object\n  ? {\n      [Key in Extract<keyof Type, string>]: Type[Key] extends Type // type of value extends the parent\n        ? [Key]\n        : // for a recursive union type, the child will never extend the parent type.\n        // but the parent will still extend the child\n        Type extends Type[Key]\n        ? [Key]\n        : Type[Key] extends ReadonlyArray<infer ArrayType> // handling recursive types with arrays\n        ? Type extends ArrayType // is the type of the parent the same as the type of the array?\n          ? [Key] // yes, it's a recursive array type\n          : // for unions, the child type extends the parent\n          ArrayType extends Type\n          ? [Key] // we have a recursive array union\n          : // child is an array, but it's not a recursive array\n            [Key, ...NestedPaths<Type[Key], [...Depth, 1]>]\n        : // child is not structured the same as the parent\n          [Key, ...NestedPaths<Type[Key], [...Depth, 1]>] | [Key];\n    }[Extract<keyof Type, string>]\n  : [];\n\n/**\n * @public\n * returns keys (strings) for every path into a schema with a value of type\n * https://docs.mongodb.com/manual/tutorial/query-embedded-documents/\n */\nexport type NestedPathsOfType<TSchema, Type> = KeysOfAType<\n  {\n    [Property in Join<NestedPaths<TSchema, []>, '.'>]: PropertyType<TSchema, Property>;\n  },\n  Type\n>;\n\n/**\n * @public\n * @experimental\n */\nexport type StrictFilter<TSchema> =\n  | Partial<TSchema>\n  | ({\n      [Property in Join<NestedPaths<WithId<TSchema>, []>, '.'>]?: Condition<\n        PropertyType<WithId<TSchema>, Property>\n      >;\n    } & RootFilterOperators<WithId<TSchema>>);\n\n/**\n * @public\n * @experimental\n */\nexport type StrictUpdateFilter<TSchema> = {\n  $currentDate?: OnlyFieldsOfType<\n    TSchema,\n    Date | Timestamp,\n    true | { $type: 'date' | 'timestamp' }\n  >;\n  $inc?: OnlyFieldsOfType<TSchema, NumericType | undefined>;\n  $min?: StrictMatchKeysAndValues<TSchema>;\n  $max?: StrictMatchKeysAndValues<TSchema>;\n  $mul?: OnlyFieldsOfType<TSchema, NumericType | undefined>;\n  $rename?: Record<string, string>;\n  $set?: StrictMatchKeysAndValues<TSchema>;\n  $setOnInsert?: StrictMatchKeysAndValues<TSchema>;\n  $unset?: OnlyFieldsOfType<TSchema, any, '' | true | 1>;\n  $addToSet?: SetFields<TSchema>;\n  $pop?: OnlyFieldsOfType<TSchema, ReadonlyArray<any>, 1 | -1>;\n  $pull?: PullOperator<TSchema>;\n  $push?: PushOperator<TSchema>;\n  $pullAll?: PullAllOperator<TSchema>;\n  $bit?: OnlyFieldsOfType<\n    TSchema,\n    NumericType | undefined,\n    { and: IntegerType } | { or: IntegerType } | { xor: IntegerType }\n  >;\n} & Document;\n\n/**\n * @public\n * @experimental\n */\nexport type StrictMatchKeysAndValues<TSchema> = Readonly<\n  {\n    [Property in Join<NestedPaths<TSchema, []>, '.'>]?: PropertyType<TSchema, Property>;\n  } & {\n    [Property in `${NestedPathsOfType<TSchema, any[]>}.$${`[${string}]` | ''}`]?: ArrayElement<\n      PropertyType<TSchema, Property extends `${infer Key}.$${string}` ? Key : never>\n    >;\n  } & {\n    [Property in `${NestedPathsOfType<TSchema, Record<string, any>[]>}.$${\n      | `[${string}]`\n      | ''}.${string}`]?: any; // Could be further narrowed\n  } & Document\n>;\n"]},"metadata":{},"sourceType":"script"}