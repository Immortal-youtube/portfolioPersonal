{"ast":null,"code":"import { HttpResponse } from \"@aws-sdk/protocol-http\";\nimport { buildQueryString } from \"@aws-sdk/querystring-builder\";\nimport { requestTimeout } from \"./request-timeout\";\nexport class FetchHttpHandler {\n  constructor(options) {\n    if (typeof options === \"function\") {\n      this.configProvider = options().then(opts => opts || {});\n    } else {\n      this.config = options ?? {};\n      this.configProvider = Promise.resolve(this.config);\n    }\n  }\n\n  destroy() {}\n\n  async handle(request) {\n    let {\n      abortSignal\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!this.config) {\n      this.config = await this.configProvider;\n    }\n\n    const requestTimeoutInMs = this.config.requestTimeout;\n\n    if (abortSignal?.aborted) {\n      const abortError = new Error(\"Request aborted\");\n      abortError.name = \"AbortError\";\n      return Promise.reject(abortError);\n    }\n\n    let path = request.path;\n\n    if (request.query) {\n      const queryString = buildQueryString(request.query);\n\n      if (queryString) {\n        path += `?${queryString}`;\n      }\n    }\n\n    const {\n      port,\n      method\n    } = request;\n    const url = `${request.protocol}//${request.hostname}${port ? `:${port}` : \"\"}${path}`;\n    const body = method === \"GET\" || method === \"HEAD\" ? undefined : request.body;\n    const requestOptions = {\n      body,\n      headers: new Headers(request.headers),\n      method: method\n    };\n\n    if (typeof AbortController !== \"undefined\") {\n      requestOptions[\"signal\"] = abortSignal;\n    }\n\n    const fetchRequest = new Request(url, requestOptions);\n    const raceOfPromises = [fetch(fetchRequest).then(response => {\n      const fetchHeaders = response.headers;\n      const transformedHeaders = {};\n\n      for (const pair of fetchHeaders.entries()) {\n        transformedHeaders[pair[0]] = pair[1];\n      }\n\n      const hasReadableStream = response.body !== undefined;\n\n      if (!hasReadableStream) {\n        return response.blob().then(body => ({\n          response: new HttpResponse({\n            headers: transformedHeaders,\n            statusCode: response.status,\n            body\n          })\n        }));\n      }\n\n      return {\n        response: new HttpResponse({\n          headers: transformedHeaders,\n          statusCode: response.status,\n          body: response.body\n        })\n      };\n    }), requestTimeout(requestTimeoutInMs)];\n\n    if (abortSignal) {\n      raceOfPromises.push(new Promise((resolve, reject) => {\n        abortSignal.onabort = () => {\n          const abortError = new Error(\"Request aborted\");\n          abortError.name = \"AbortError\";\n          reject(abortError);\n        };\n      }));\n    }\n\n    return Promise.race(raceOfPromises);\n  }\n\n}","map":{"version":3,"names":["HttpResponse","buildQueryString","requestTimeout","FetchHttpHandler","constructor","options","configProvider","then","opts","config","Promise","resolve","destroy","handle","request","abortSignal","requestTimeoutInMs","aborted","abortError","Error","name","reject","path","query","queryString","port","method","url","protocol","hostname","body","undefined","requestOptions","headers","Headers","AbortController","fetchRequest","Request","raceOfPromises","fetch","response","fetchHeaders","transformedHeaders","pair","entries","hasReadableStream","blob","statusCode","status","push","onabort","race"],"sources":["C:/Users/anshs/OneDrive/Documents/Code/WebDevelopement/portfolioPersonal/node_modules/@aws-sdk/fetch-http-handler/dist-es/fetch-http-handler.js"],"sourcesContent":["import { HttpResponse } from \"@aws-sdk/protocol-http\";\nimport { buildQueryString } from \"@aws-sdk/querystring-builder\";\nimport { requestTimeout } from \"./request-timeout\";\nexport class FetchHttpHandler {\n    constructor(options) {\n        if (typeof options === \"function\") {\n            this.configProvider = options().then((opts) => opts || {});\n        }\n        else {\n            this.config = options ?? {};\n            this.configProvider = Promise.resolve(this.config);\n        }\n    }\n    destroy() {\n    }\n    async handle(request, { abortSignal } = {}) {\n        if (!this.config) {\n            this.config = await this.configProvider;\n        }\n        const requestTimeoutInMs = this.config.requestTimeout;\n        if (abortSignal?.aborted) {\n            const abortError = new Error(\"Request aborted\");\n            abortError.name = \"AbortError\";\n            return Promise.reject(abortError);\n        }\n        let path = request.path;\n        if (request.query) {\n            const queryString = buildQueryString(request.query);\n            if (queryString) {\n                path += `?${queryString}`;\n            }\n        }\n        const { port, method } = request;\n        const url = `${request.protocol}//${request.hostname}${port ? `:${port}` : \"\"}${path}`;\n        const body = method === \"GET\" || method === \"HEAD\" ? undefined : request.body;\n        const requestOptions = {\n            body,\n            headers: new Headers(request.headers),\n            method: method,\n        };\n        if (typeof AbortController !== \"undefined\") {\n            requestOptions[\"signal\"] = abortSignal;\n        }\n        const fetchRequest = new Request(url, requestOptions);\n        const raceOfPromises = [\n            fetch(fetchRequest).then((response) => {\n                const fetchHeaders = response.headers;\n                const transformedHeaders = {};\n                for (const pair of fetchHeaders.entries()) {\n                    transformedHeaders[pair[0]] = pair[1];\n                }\n                const hasReadableStream = response.body !== undefined;\n                if (!hasReadableStream) {\n                    return response.blob().then((body) => ({\n                        response: new HttpResponse({\n                            headers: transformedHeaders,\n                            statusCode: response.status,\n                            body,\n                        }),\n                    }));\n                }\n                return {\n                    response: new HttpResponse({\n                        headers: transformedHeaders,\n                        statusCode: response.status,\n                        body: response.body,\n                    }),\n                };\n            }),\n            requestTimeout(requestTimeoutInMs),\n        ];\n        if (abortSignal) {\n            raceOfPromises.push(new Promise((resolve, reject) => {\n                abortSignal.onabort = () => {\n                    const abortError = new Error(\"Request aborted\");\n                    abortError.name = \"AbortError\";\n                    reject(abortError);\n                };\n            }));\n        }\n        return Promise.race(raceOfPromises);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}