{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DropDatabaseOperation = exports.DropCollectionOperation = void 0;\n\nconst error_1 = require(\"../error\");\n\nconst command_1 = require(\"./command\");\n\nconst operation_1 = require(\"./operation\");\n/** @internal */\n\n\nclass DropCollectionOperation extends command_1.CommandOperation {\n  constructor(db, name) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super(db, options);\n    this.db = db;\n    this.options = options;\n    this.name = name;\n  }\n\n  execute(server, session, callback) {\n    (async () => {\n      const db = this.db;\n      const options = this.options;\n      const name = this.name;\n      const encryptedFieldsMap = db.s.client.options.autoEncryption?.encryptedFieldsMap;\n      let encryptedFields = options.encryptedFields ?? encryptedFieldsMap?.[`${db.databaseName}.${name}`];\n\n      if (!encryptedFields && encryptedFieldsMap) {\n        // If the MongoClient was configured with an encryptedFieldsMap,\n        // and no encryptedFields config was available in it or explicitly\n        // passed as an argument, the spec tells us to look one up using\n        // listCollections().\n        const listCollectionsResult = await db.listCollections({\n          name\n        }, {\n          nameOnly: false\n        }).toArray();\n        encryptedFields = listCollectionsResult?.[0]?.options?.encryptedFields;\n      }\n\n      if (encryptedFields) {\n        const escCollection = encryptedFields.escCollection || `enxcol_.${name}.esc`;\n        const eccCollection = encryptedFields.eccCollection || `enxcol_.${name}.ecc`;\n        const ecocCollection = encryptedFields.ecocCollection || `enxcol_.${name}.ecoc`;\n\n        for (const collectionName of [escCollection, eccCollection, ecocCollection]) {\n          // Drop auxilliary collections, ignoring potential NamespaceNotFound errors.\n          const dropOp = new DropCollectionOperation(db, collectionName);\n\n          try {\n            await dropOp.executeWithoutEncryptedFieldsCheck(server, session);\n          } catch (err) {\n            if (!(err instanceof error_1.MongoServerError) || err.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {\n              throw err;\n            }\n          }\n        }\n      }\n\n      return this.executeWithoutEncryptedFieldsCheck(server, session);\n    })().then(result => callback(undefined, result), err => callback(err));\n  }\n\n  executeWithoutEncryptedFieldsCheck(server, session) {\n    return new Promise((resolve, reject) => {\n      super.executeCommand(server, session, {\n        drop: this.name\n      }, (err, result) => {\n        if (err) return reject(err);\n        resolve(!!result.ok);\n      });\n    });\n  }\n\n}\n\nexports.DropCollectionOperation = DropCollectionOperation;\n/** @internal */\n\nclass DropDatabaseOperation extends command_1.CommandOperation {\n  constructor(db, options) {\n    super(db, options);\n    this.options = options;\n  }\n\n  execute(server, session, callback) {\n    super.executeCommand(server, session, {\n      dropDatabase: 1\n    }, (err, result) => {\n      if (err) return callback(err);\n      if (result.ok) return callback(undefined, true);\n      callback(undefined, false);\n    });\n  }\n\n}\n\nexports.DropDatabaseOperation = DropDatabaseOperation;\n(0, operation_1.defineAspects)(DropCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(DropDatabaseOperation, [operation_1.Aspect.WRITE_OPERATION]);","map":{"version":3,"mappings":"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","names":["DropCollectionOperation","command_1","constructor","db","name","options","execute","server","session","callback","encryptedFieldsMap","s","client","autoEncryption","encryptedFields","databaseName","listCollectionsResult","listCollections","nameOnly","toArray","escCollection","eccCollection","ecocCollection","collectionName","dropOp","executeWithoutEncryptedFieldsCheck","err","error_1","code","NamespaceNotFound","then","result","undefined","Promise","resolve","reject","executeCommand","drop","ok","exports","DropDatabaseOperation","dropDatabase","operation_1","WRITE_OPERATION"],"sources":["C:\\Users\\anshs\\OneDrive\\Documents\\Code\\WebDevelopement\\portfolioPersonal\\node_modules\\mongodb\\src\\operations\\drop.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport type { Db } from '../db';\nimport { MONGODB_ERROR_CODES, MongoServerError } from '../error';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport type { Callback } from '../utils';\nimport { CommandOperation, CommandOperationOptions } from './command';\nimport { Aspect, defineAspects } from './operation';\n\n/** @public */\nexport interface DropCollectionOptions extends CommandOperationOptions {\n  /** @experimental */\n  encryptedFields?: Document;\n}\n\n/** @internal */\nexport class DropCollectionOperation extends CommandOperation<boolean> {\n  override options: DropCollectionOptions;\n  db: Db;\n  name: string;\n\n  constructor(db: Db, name: string, options: DropCollectionOptions = {}) {\n    super(db, options);\n    this.db = db;\n    this.options = options;\n    this.name = name;\n  }\n\n  override execute(\n    server: Server,\n    session: ClientSession | undefined,\n    callback: Callback<boolean>\n  ): void {\n    (async () => {\n      const db = this.db;\n      const options = this.options;\n      const name = this.name;\n\n      const encryptedFieldsMap = db.s.client.options.autoEncryption?.encryptedFieldsMap;\n      let encryptedFields: Document | undefined =\n        options.encryptedFields ?? encryptedFieldsMap?.[`${db.databaseName}.${name}`];\n\n      if (!encryptedFields && encryptedFieldsMap) {\n        // If the MongoClient was configured with an encryptedFieldsMap,\n        // and no encryptedFields config was available in it or explicitly\n        // passed as an argument, the spec tells us to look one up using\n        // listCollections().\n        const listCollectionsResult = await db\n          .listCollections({ name }, { nameOnly: false })\n          .toArray();\n        encryptedFields = listCollectionsResult?.[0]?.options?.encryptedFields;\n      }\n\n      if (encryptedFields) {\n        const escCollection = encryptedFields.escCollection || `enxcol_.${name}.esc`;\n        const eccCollection = encryptedFields.eccCollection || `enxcol_.${name}.ecc`;\n        const ecocCollection = encryptedFields.ecocCollection || `enxcol_.${name}.ecoc`;\n\n        for (const collectionName of [escCollection, eccCollection, ecocCollection]) {\n          // Drop auxilliary collections, ignoring potential NamespaceNotFound errors.\n          const dropOp = new DropCollectionOperation(db, collectionName);\n          try {\n            await dropOp.executeWithoutEncryptedFieldsCheck(server, session);\n          } catch (err) {\n            if (\n              !(err instanceof MongoServerError) ||\n              err.code !== MONGODB_ERROR_CODES.NamespaceNotFound\n            ) {\n              throw err;\n            }\n          }\n        }\n      }\n\n      return this.executeWithoutEncryptedFieldsCheck(server, session);\n    })().then(\n      result => callback(undefined, result),\n      err => callback(err)\n    );\n  }\n\n  private executeWithoutEncryptedFieldsCheck(\n    server: Server,\n    session: ClientSession | undefined\n  ): Promise<boolean> {\n    return new Promise<boolean>((resolve, reject) => {\n      super.executeCommand(server, session, { drop: this.name }, (err, result) => {\n        if (err) return reject(err);\n        resolve(!!result.ok);\n      });\n    });\n  }\n}\n\n/** @public */\nexport type DropDatabaseOptions = CommandOperationOptions;\n\n/** @internal */\nexport class DropDatabaseOperation extends CommandOperation<boolean> {\n  override options: DropDatabaseOptions;\n\n  constructor(db: Db, options: DropDatabaseOptions) {\n    super(db, options);\n    this.options = options;\n  }\n  override execute(\n    server: Server,\n    session: ClientSession | undefined,\n    callback: Callback<boolean>\n  ): void {\n    super.executeCommand(server, session, { dropDatabase: 1 }, (err, result) => {\n      if (err) return callback(err);\n      if (result.ok) return callback(undefined, true);\n      callback(undefined, false);\n    });\n  }\n}\n\ndefineAspects(DropCollectionOperation, [Aspect.WRITE_OPERATION]);\ndefineAspects(DropDatabaseOperation, [Aspect.WRITE_OPERATION]);\n"]},"metadata":{},"sourceType":"script"}