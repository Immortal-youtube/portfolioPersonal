{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isSharded = exports.applyCommonQueryOptions = exports.getReadPreference = void 0;\n\nconst error_1 = require(\"../../error\");\n\nconst read_preference_1 = require(\"../../read_preference\");\n\nconst common_1 = require(\"../../sdam/common\");\n\nconst topology_description_1 = require(\"../../sdam/topology_description\");\n\nfunction getReadPreference(cmd, options) {\n  // Default to command version of the readPreference\n  let readPreference = cmd.readPreference || read_preference_1.ReadPreference.primary; // If we have an option readPreference override the command one\n\n  if (options?.readPreference) {\n    readPreference = options.readPreference;\n  }\n\n  if (typeof readPreference === 'string') {\n    readPreference = read_preference_1.ReadPreference.fromString(readPreference);\n  }\n\n  if (!(readPreference instanceof read_preference_1.ReadPreference)) {\n    throw new error_1.MongoInvalidArgumentError('Option \"readPreference\" must be a ReadPreference instance');\n  }\n\n  return readPreference;\n}\n\nexports.getReadPreference = getReadPreference;\n\nfunction applyCommonQueryOptions(queryOptions, options) {\n  Object.assign(queryOptions, {\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n    enableUtf8Validation: typeof options.enableUtf8Validation === 'boolean' ? options.enableUtf8Validation : true\n  });\n\n  if (options.session) {\n    queryOptions.session = options.session;\n  }\n\n  return queryOptions;\n}\n\nexports.applyCommonQueryOptions = applyCommonQueryOptions;\n\nfunction isSharded(topologyOrServer) {\n  if (topologyOrServer == null) {\n    return false;\n  }\n\n  if (topologyOrServer.description && topologyOrServer.description.type === common_1.ServerType.Mongos) {\n    return true;\n  } // NOTE: This is incredibly inefficient, and should be removed once command construction\n  //       happens based on `Server` not `Topology`.\n\n\n  if (topologyOrServer.description && topologyOrServer.description instanceof topology_description_1.TopologyDescription) {\n    const servers = Array.from(topologyOrServer.description.servers.values());\n    return servers.some(server => server.type === common_1.ServerType.Mongos);\n  }\n\n  return false;\n}\n\nexports.isSharded = isSharded;","map":{"version":3,"mappings":";;;;;;;AACA;;AAEA;;AACA;;AAIA;;AAQA,SAAgBA,iBAAhB,CAAkCC,GAAlC,EAAiDC,OAAjD,EAA+E;EAC7E;EACA,IAAIC,cAAc,GAAGF,GAAG,CAACE,cAAJ,IAAsBC,iCAAeC,OAA1D,CAF6E,CAG7E;;EACA,IAAIH,OAAO,EAAEC,cAAb,EAA6B;IAC3BA,cAAc,GAAGD,OAAO,CAACC,cAAzB;EACD;;EAED,IAAI,OAAOA,cAAP,KAA0B,QAA9B,EAAwC;IACtCA,cAAc,GAAGC,iCAAeE,UAAf,CAA0BH,cAA1B,CAAjB;EACD;;EAED,IAAI,EAAEA,cAAc,YAAYC,gCAA5B,CAAJ,EAAiD;IAC/C,MAAM,IAAIG,iCAAJ,CACJ,2DADI,CAAN;EAGD;;EAED,OAAOJ,cAAP;AACD;;AAnBDK;;AAqBA,SAAgBC,uBAAhB,CACEC,YADF,EAEER,OAFF,EAEyB;EAEvBS,MAAM,CAACC,MAAP,CAAcF,YAAd,EAA4B;IAC1BG,GAAG,EAAE,OAAOX,OAAO,CAACW,GAAf,KAAuB,SAAvB,GAAmCX,OAAO,CAACW,GAA3C,GAAiD,KAD5B;IAE1BC,YAAY,EAAE,OAAOZ,OAAO,CAACY,YAAf,KAAgC,SAAhC,GAA4CZ,OAAO,CAACY,YAApD,GAAmE,IAFvD;IAG1BC,aAAa,EAAE,OAAOb,OAAO,CAACa,aAAf,KAAiC,SAAjC,GAA6Cb,OAAO,CAACa,aAArD,GAAqE,IAH1D;IAI1BC,cAAc,EAAE,OAAOd,OAAO,CAACc,cAAf,KAAkC,SAAlC,GAA8Cd,OAAO,CAACc,cAAtD,GAAuE,KAJ7D;IAK1BC,UAAU,EAAE,OAAOf,OAAO,CAACe,UAAf,KAA8B,SAA9B,GAA0Cf,OAAO,CAACe,UAAlD,GAA+D,KALjD;IAM1BC,oBAAoB,EAClB,OAAOhB,OAAO,CAACgB,oBAAf,KAAwC,SAAxC,GAAoDhB,OAAO,CAACgB,oBAA5D,GAAmF;EAP3D,CAA5B;;EAUA,IAAIhB,OAAO,CAACiB,OAAZ,EAAqB;IACnBT,YAAY,CAACS,OAAb,GAAuBjB,OAAO,CAACiB,OAA/B;EACD;;EAED,OAAOT,YAAP;AACD;;AAnBDF;;AAqBA,SAAgBY,SAAhB,CAA0BC,gBAA1B,EAA2E;EACzE,IAAIA,gBAAgB,IAAI,IAAxB,EAA8B;IAC5B,OAAO,KAAP;EACD;;EAED,IAAIA,gBAAgB,CAACC,WAAjB,IAAgCD,gBAAgB,CAACC,WAAjB,CAA6BC,IAA7B,KAAsCC,oBAAWC,MAArF,EAA6F;IAC3F,OAAO,IAAP;EACD,CAPwE,CASzE;EACA;;;EACA,IAAIJ,gBAAgB,CAACC,WAAjB,IAAgCD,gBAAgB,CAACC,WAAjB,YAAwCI,0CAA5E,EAAiG;IAC/F,MAAMC,OAAO,GAAwBC,KAAK,CAACC,IAAN,CAAWR,gBAAgB,CAACC,WAAjB,CAA6BK,OAA7B,CAAqCG,MAArC,EAAX,CAArC;IACA,OAAOH,OAAO,CAACI,IAAR,CAAcC,MAAD,IAA+BA,MAAM,CAACT,IAAP,KAAgBC,oBAAWC,MAAvE,CAAP;EACD;;EAED,OAAO,KAAP;AACD;;AAjBDjB","names":["getReadPreference","cmd","options","readPreference","read_preference_1","primary","fromString","error_1","exports","applyCommonQueryOptions","queryOptions","Object","assign","raw","promoteLongs","promoteValues","promoteBuffers","bsonRegExp","enableUtf8Validation","session","isSharded","topologyOrServer","description","type","common_1","Mongos","topology_description_1","servers","Array","from","values","some","server"],"sources":["C:\\Users\\anshs\\OneDrive\\Documents\\Code\\WebDevelopement\\portfolioPersonal\\node_modules\\mongodb\\src\\cmap\\wire_protocol\\shared.ts"],"sourcesContent":["import type { Document } from '../../bson';\nimport { MongoInvalidArgumentError } from '../../error';\nimport type { ReadPreferenceLike } from '../../read_preference';\nimport { ReadPreference } from '../../read_preference';\nimport { ServerType } from '../../sdam/common';\nimport type { Server } from '../../sdam/server';\nimport type { ServerDescription } from '../../sdam/server_description';\nimport type { Topology } from '../../sdam/topology';\nimport { TopologyDescription } from '../../sdam/topology_description';\nimport type { OpQueryOptions } from '../commands';\nimport type { CommandOptions, Connection } from '../connection';\n\nexport interface ReadPreferenceOption {\n  readPreference?: ReadPreferenceLike;\n}\n\nexport function getReadPreference(cmd: Document, options?: ReadPreferenceOption): ReadPreference {\n  // Default to command version of the readPreference\n  let readPreference = cmd.readPreference || ReadPreference.primary;\n  // If we have an option readPreference override the command one\n  if (options?.readPreference) {\n    readPreference = options.readPreference;\n  }\n\n  if (typeof readPreference === 'string') {\n    readPreference = ReadPreference.fromString(readPreference);\n  }\n\n  if (!(readPreference instanceof ReadPreference)) {\n    throw new MongoInvalidArgumentError(\n      'Option \"readPreference\" must be a ReadPreference instance'\n    );\n  }\n\n  return readPreference;\n}\n\nexport function applyCommonQueryOptions(\n  queryOptions: OpQueryOptions,\n  options: CommandOptions\n): CommandOptions {\n  Object.assign(queryOptions, {\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n    enableUtf8Validation:\n      typeof options.enableUtf8Validation === 'boolean' ? options.enableUtf8Validation : true\n  });\n\n  if (options.session) {\n    queryOptions.session = options.session;\n  }\n\n  return queryOptions;\n}\n\nexport function isSharded(topologyOrServer?: Topology | Server | Connection): boolean {\n  if (topologyOrServer == null) {\n    return false;\n  }\n\n  if (topologyOrServer.description && topologyOrServer.description.type === ServerType.Mongos) {\n    return true;\n  }\n\n  // NOTE: This is incredibly inefficient, and should be removed once command construction\n  //       happens based on `Server` not `Topology`.\n  if (topologyOrServer.description && topologyOrServer.description instanceof TopologyDescription) {\n    const servers: ServerDescription[] = Array.from(topologyOrServer.description.servers.values());\n    return servers.some((server: ServerDescription) => server.type === ServerType.Mongos);\n  }\n\n  return false;\n}\n"]},"metadata":{},"sourceType":"script"}