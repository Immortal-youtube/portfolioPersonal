{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LEGAL_TCP_SOCKET_OPTIONS = exports.LEGAL_TLS_SOCKET_OPTIONS = exports.prepareHandshakeDocument = exports.connect = void 0;\n\nconst net = require(\"net\");\n\nconst socks_1 = require(\"socks\");\n\nconst tls = require(\"tls\");\n\nconst bson_1 = require(\"../bson\");\n\nconst constants_1 = require(\"../constants\");\n\nconst error_1 = require(\"../error\");\n\nconst utils_1 = require(\"../utils\");\n\nconst auth_provider_1 = require(\"./auth/auth_provider\");\n\nconst gssapi_1 = require(\"./auth/gssapi\");\n\nconst mongocr_1 = require(\"./auth/mongocr\");\n\nconst mongodb_aws_1 = require(\"./auth/mongodb_aws\");\n\nconst plain_1 = require(\"./auth/plain\");\n\nconst providers_1 = require(\"./auth/providers\");\n\nconst scram_1 = require(\"./auth/scram\");\n\nconst x509_1 = require(\"./auth/x509\");\n\nconst connection_1 = require(\"./connection\");\n\nconst constants_2 = require(\"./wire_protocol/constants\");\n\nconst AUTH_PROVIDERS = new Map([[providers_1.AuthMechanism.MONGODB_AWS, new mongodb_aws_1.MongoDBAWS()], [providers_1.AuthMechanism.MONGODB_CR, new mongocr_1.MongoCR()], [providers_1.AuthMechanism.MONGODB_GSSAPI, new gssapi_1.GSSAPI()], [providers_1.AuthMechanism.MONGODB_PLAIN, new plain_1.Plain()], [providers_1.AuthMechanism.MONGODB_SCRAM_SHA1, new scram_1.ScramSHA1()], [providers_1.AuthMechanism.MONGODB_SCRAM_SHA256, new scram_1.ScramSHA256()], [providers_1.AuthMechanism.MONGODB_X509, new x509_1.X509()]]);\n\nfunction connect(options, callback) {\n  makeConnection({ ...options,\n    existingSocket: undefined\n  }, (err, socket) => {\n    if (err || !socket) {\n      return callback(err);\n    }\n\n    let ConnectionType = options.connectionType ?? connection_1.Connection;\n\n    if (options.autoEncrypter) {\n      ConnectionType = connection_1.CryptoConnection;\n    }\n\n    performInitialHandshake(new ConnectionType(socket, options), options, callback);\n  });\n}\n\nexports.connect = connect;\n\nfunction checkSupportedServer(hello, options) {\n  const serverVersionHighEnough = hello && (typeof hello.maxWireVersion === 'number' || hello.maxWireVersion instanceof bson_1.Int32) && hello.maxWireVersion >= constants_2.MIN_SUPPORTED_WIRE_VERSION;\n  const serverVersionLowEnough = hello && (typeof hello.minWireVersion === 'number' || hello.minWireVersion instanceof bson_1.Int32) && hello.minWireVersion <= constants_2.MAX_SUPPORTED_WIRE_VERSION;\n\n  if (serverVersionHighEnough) {\n    if (serverVersionLowEnough) {\n      return null;\n    }\n\n    const message = `Server at ${options.hostAddress} reports minimum wire version ${JSON.stringify(hello.minWireVersion)}, but this version of the Node.js Driver requires at most ${constants_2.MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_2.MAX_SUPPORTED_SERVER_VERSION})`;\n    return new error_1.MongoCompatibilityError(message);\n  }\n\n  const message = `Server at ${options.hostAddress} reports maximum wire version ${JSON.stringify(hello.maxWireVersion) ?? 0}, but this version of the Node.js Driver requires at least ${constants_2.MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_2.MIN_SUPPORTED_SERVER_VERSION})`;\n  return new error_1.MongoCompatibilityError(message);\n}\n\nfunction performInitialHandshake(conn, options, _callback) {\n  const callback = function (err, ret) {\n    if (err && conn) {\n      conn.destroy();\n    }\n\n    _callback(err, ret);\n  };\n\n  const credentials = options.credentials;\n\n  if (credentials) {\n    if (!(credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT) && !AUTH_PROVIDERS.get(credentials.mechanism)) {\n      callback(new error_1.MongoInvalidArgumentError(`AuthMechanism '${credentials.mechanism}' not supported`));\n      return;\n    }\n  }\n\n  const authContext = new auth_provider_1.AuthContext(conn, credentials, options);\n  prepareHandshakeDocument(authContext, (err, handshakeDoc) => {\n    if (err || !handshakeDoc) {\n      return callback(err);\n    }\n\n    const handshakeOptions = Object.assign({}, options);\n\n    if (typeof options.connectTimeoutMS === 'number') {\n      // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\n      handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;\n    }\n\n    const start = new Date().getTime();\n    conn.command((0, utils_1.ns)('admin.$cmd'), handshakeDoc, handshakeOptions, (err, response) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      if (response?.ok === 0) {\n        callback(new error_1.MongoServerError(response));\n        return;\n      }\n\n      if (!('isWritablePrimary' in response)) {\n        // Provide hello-style response document.\n        response.isWritablePrimary = response[constants_1.LEGACY_HELLO_COMMAND];\n      }\n\n      if (response.helloOk) {\n        conn.helloOk = true;\n      }\n\n      const supportedServerErr = checkSupportedServer(response, options);\n\n      if (supportedServerErr) {\n        callback(supportedServerErr);\n        return;\n      }\n\n      if (options.loadBalanced) {\n        if (!response.serviceId) {\n          return callback(new error_1.MongoCompatibilityError('Driver attempted to initialize in load balancing mode, ' + 'but the server does not support this mode.'));\n        }\n      } // NOTE: This is metadata attached to the connection while porting away from\n      //       handshake being done in the `Server` class. Likely, it should be\n      //       relocated, or at very least restructured.\n\n\n      conn.hello = response;\n      conn.lastHelloMS = new Date().getTime() - start;\n\n      if (!response.arbiterOnly && credentials) {\n        // store the response on auth context\n        authContext.response = response;\n        const resolvedCredentials = credentials.resolveAuthMechanism(response);\n        const provider = AUTH_PROVIDERS.get(resolvedCredentials.mechanism);\n\n        if (!provider) {\n          return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${resolvedCredentials.mechanism} defined.`));\n        }\n\n        provider.auth(authContext, err => {\n          if (err) {\n            if (err instanceof error_1.MongoError) {\n              err.addErrorLabel(error_1.MongoErrorLabel.HandshakeError);\n\n              if ((0, error_1.needsRetryableWriteLabel)(err, response.maxWireVersion)) {\n                err.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);\n              }\n            }\n\n            return callback(err);\n          }\n\n          callback(undefined, conn);\n        });\n        return;\n      }\n\n      callback(undefined, conn);\n    });\n  });\n}\n/**\n * @internal\n *\n * This function is only exposed for testing purposes.\n */\n\n\nfunction prepareHandshakeDocument(authContext, callback) {\n  const options = authContext.options;\n  const compressors = options.compressors ? options.compressors : [];\n  const {\n    serverApi\n  } = authContext.connection;\n  const handshakeDoc = {\n    [serverApi?.version ? 'hello' : constants_1.LEGACY_HELLO_COMMAND]: 1,\n    helloOk: true,\n    client: options.metadata || (0, utils_1.makeClientMetadata)(options),\n    compression: compressors\n  };\n\n  if (options.loadBalanced === true) {\n    handshakeDoc.loadBalanced = true;\n  }\n\n  const credentials = authContext.credentials;\n\n  if (credentials) {\n    if (credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT && credentials.username) {\n      handshakeDoc.saslSupportedMechs = `${credentials.source}.${credentials.username}`;\n      const provider = AUTH_PROVIDERS.get(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256);\n\n      if (!provider) {\n        // This auth mechanism is always present.\n        return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${providers_1.AuthMechanism.MONGODB_SCRAM_SHA256} defined.`));\n      }\n\n      return provider.prepare(handshakeDoc, authContext, callback);\n    }\n\n    const provider = AUTH_PROVIDERS.get(credentials.mechanism);\n\n    if (!provider) {\n      return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${credentials.mechanism} defined.`));\n    }\n\n    return provider.prepare(handshakeDoc, authContext, callback);\n  }\n\n  callback(undefined, handshakeDoc);\n}\n\nexports.prepareHandshakeDocument = prepareHandshakeDocument;\n/** @public */\n\nexports.LEGAL_TLS_SOCKET_OPTIONS = ['ALPNProtocols', 'ca', 'cert', 'checkServerIdentity', 'ciphers', 'crl', 'ecdhCurve', 'key', 'minDHSize', 'passphrase', 'pfx', 'rejectUnauthorized', 'secureContext', 'secureProtocol', 'servername', 'session'];\n/** @public */\n\nexports.LEGAL_TCP_SOCKET_OPTIONS = ['family', 'hints', 'localAddress', 'localPort', 'lookup'];\n\nfunction parseConnectOptions(options) {\n  const hostAddress = options.hostAddress;\n  if (!hostAddress) throw new error_1.MongoInvalidArgumentError('Option \"hostAddress\" is required');\n  const result = {};\n\n  for (const name of exports.LEGAL_TCP_SOCKET_OPTIONS) {\n    if (options[name] != null) {\n      result[name] = options[name];\n    }\n  }\n\n  if (typeof hostAddress.socketPath === 'string') {\n    result.path = hostAddress.socketPath;\n    return result;\n  } else if (typeof hostAddress.host === 'string') {\n    result.host = hostAddress.host;\n    result.port = hostAddress.port;\n    return result;\n  } else {\n    // This should never happen since we set up HostAddresses\n    // But if we don't throw here the socket could hang until timeout\n    // TODO(NODE-3483)\n    throw new error_1.MongoRuntimeError(`Unexpected HostAddress ${JSON.stringify(hostAddress)}`);\n  }\n}\n\nfunction parseSslOptions(options) {\n  const result = parseConnectOptions(options); // Merge in valid SSL options\n\n  for (const name of exports.LEGAL_TLS_SOCKET_OPTIONS) {\n    if (options[name] != null) {\n      result[name] = options[name];\n    }\n  }\n\n  if (options.existingSocket) {\n    result.socket = options.existingSocket;\n  } // Set default sni servername to be the same as host\n\n\n  if (result.servername == null && result.host && !net.isIP(result.host)) {\n    result.servername = result.host;\n  }\n\n  return result;\n}\n\nconst SOCKET_ERROR_EVENT_LIST = ['error', 'close', 'timeout', 'parseError'];\nconst SOCKET_ERROR_EVENTS = new Set(SOCKET_ERROR_EVENT_LIST);\n\nfunction makeConnection(options, _callback) {\n  const useTLS = options.tls ?? false;\n  const keepAlive = options.keepAlive ?? true;\n  const socketTimeoutMS = options.socketTimeoutMS ?? Reflect.get(options, 'socketTimeout') ?? 0;\n  const noDelay = options.noDelay ?? true;\n  const connectTimeoutMS = options.connectTimeoutMS ?? 30000;\n  const rejectUnauthorized = options.rejectUnauthorized ?? true;\n  const keepAliveInitialDelay = ((options.keepAliveInitialDelay ?? 120000) > socketTimeoutMS ? Math.round(socketTimeoutMS / 2) : options.keepAliveInitialDelay) ?? 120000;\n  const existingSocket = options.existingSocket;\n  let socket;\n\n  const callback = function (err, ret) {\n    if (err && socket) {\n      socket.destroy();\n    }\n\n    _callback(err, ret);\n  };\n\n  if (options.proxyHost != null) {\n    // Currently, only Socks5 is supported.\n    return makeSocks5Connection({ ...options,\n      connectTimeoutMS // Should always be present for Socks5\n\n    }, callback);\n  }\n\n  if (useTLS) {\n    const tlsSocket = tls.connect(parseSslOptions(options));\n\n    if (typeof tlsSocket.disableRenegotiation === 'function') {\n      tlsSocket.disableRenegotiation();\n    }\n\n    socket = tlsSocket;\n  } else if (existingSocket) {\n    // In the TLS case, parseSslOptions() sets options.socket to existingSocket,\n    // so we only need to handle the non-TLS case here (where existingSocket\n    // gives us all we need out of the box).\n    socket = existingSocket;\n  } else {\n    socket = net.createConnection(parseConnectOptions(options));\n  }\n\n  socket.setKeepAlive(keepAlive, keepAliveInitialDelay);\n  socket.setTimeout(connectTimeoutMS);\n  socket.setNoDelay(noDelay);\n  const connectEvent = useTLS ? 'secureConnect' : 'connect';\n  let cancellationHandler;\n\n  function errorHandler(eventName) {\n    return err => {\n      SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n\n      if (cancellationHandler && options.cancellationToken) {\n        options.cancellationToken.removeListener('cancel', cancellationHandler);\n      }\n\n      socket.removeListener(connectEvent, connectHandler);\n      callback(connectionFailureError(eventName, err));\n    };\n  }\n\n  function connectHandler() {\n    SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n\n    if (cancellationHandler && options.cancellationToken) {\n      options.cancellationToken.removeListener('cancel', cancellationHandler);\n    }\n\n    if ('authorizationError' in socket) {\n      if (socket.authorizationError && rejectUnauthorized) {\n        return callback(socket.authorizationError);\n      }\n    }\n\n    socket.setTimeout(socketTimeoutMS);\n    callback(undefined, socket);\n  }\n\n  SOCKET_ERROR_EVENTS.forEach(event => socket.once(event, errorHandler(event)));\n\n  if (options.cancellationToken) {\n    cancellationHandler = errorHandler('cancel');\n    options.cancellationToken.once('cancel', cancellationHandler);\n  }\n\n  if (existingSocket) {\n    process.nextTick(connectHandler);\n  } else {\n    socket.once(connectEvent, connectHandler);\n  }\n}\n\nfunction makeSocks5Connection(options, callback) {\n  const hostAddress = utils_1.HostAddress.fromHostPort(options.proxyHost ?? '', // proxyHost is guaranteed to set here\n  options.proxyPort ?? 1080); // First, connect to the proxy server itself:\n\n  makeConnection({ ...options,\n    hostAddress,\n    tls: false,\n    proxyHost: undefined\n  }, (err, rawSocket) => {\n    if (err) {\n      return callback(err);\n    }\n\n    const destination = parseConnectOptions(options);\n\n    if (typeof destination.host !== 'string' || typeof destination.port !== 'number') {\n      return callback(new error_1.MongoInvalidArgumentError('Can only make Socks5 connections to TCP hosts'));\n    } // Then, establish the Socks5 proxy connection:\n\n\n    socks_1.SocksClient.createConnection({\n      existing_socket: rawSocket,\n      timeout: options.connectTimeoutMS,\n      command: 'connect',\n      destination: {\n        host: destination.host,\n        port: destination.port\n      },\n      proxy: {\n        // host and port are ignored because we pass existing_socket\n        host: 'iLoveJavaScript',\n        port: 0,\n        type: 5,\n        userId: options.proxyUsername || undefined,\n        password: options.proxyPassword || undefined\n      }\n    }).then(_ref => {\n      let {\n        socket\n      } = _ref;\n      // Finally, now treat the resulting duplex stream as the\n      // socket over which we send and receive wire protocol messages:\n      makeConnection({ ...options,\n        existingSocket: socket,\n        proxyHost: undefined\n      }, callback);\n    }, error => callback(connectionFailureError('error', error)));\n  });\n}\n\nfunction connectionFailureError(type, err) {\n  switch (type) {\n    case 'error':\n      return new error_1.MongoNetworkError(err);\n\n    case 'timeout':\n      return new error_1.MongoNetworkTimeoutError('connection timed out');\n\n    case 'close':\n      return new error_1.MongoNetworkError('connection closed');\n\n    case 'cancel':\n      return new error_1.MongoNetworkError('connection establishment was cancelled');\n\n    default:\n      return new error_1.MongoNetworkError('unknown network error');\n  }\n}","map":{"version":3,"mappings":"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","names":["AUTH_PROVIDERS","Map","providers_1","MONGODB_AWS","mongodb_aws_1","MONGODB_CR","mongocr_1","MONGODB_GSSAPI","gssapi_1","MONGODB_PLAIN","plain_1","MONGODB_SCRAM_SHA1","scram_1","MONGODB_SCRAM_SHA256","MONGODB_X509","x509_1","connect","options","callback","makeConnection","existingSocket","undefined","err","socket","ConnectionType","connectionType","connection_1","autoEncrypter","performInitialHandshake","exports","checkSupportedServer","hello","serverVersionHighEnough","maxWireVersion","bson_1","constants_2","serverVersionLowEnough","minWireVersion","message","hostAddress","JSON","stringify","error_1","conn","_callback","ret","destroy","credentials","mechanism","MONGODB_DEFAULT","get","authContext","auth_provider_1","prepareHandshakeDocument","handshakeDoc","handshakeOptions","Object","assign","connectTimeoutMS","socketTimeoutMS","start","Date","getTime","command","response","ok","isWritablePrimary","constants_1","helloOk","supportedServerErr","loadBalanced","serviceId","lastHelloMS","arbiterOnly","resolvedCredentials","resolveAuthMechanism","provider","auth","addErrorLabel","HandshakeError","RetryableWriteError","compressors","serverApi","connection","version","client","metadata","compression","username","saslSupportedMechs","source","prepare","parseConnectOptions","result","name","socketPath","path","host","port","parseSslOptions","servername","net","isIP","SOCKET_ERROR_EVENT_LIST","SOCKET_ERROR_EVENTS","Set","useTLS","tls","keepAlive","Reflect","noDelay","rejectUnauthorized","keepAliveInitialDelay","Math","round","proxyHost","makeSocks5Connection","tlsSocket","disableRenegotiation","createConnection","setKeepAlive","setTimeout","setNoDelay","connectEvent","cancellationHandler","errorHandler","eventName","forEach","event","removeAllListeners","cancellationToken","removeListener","connectHandler","connectionFailureError","authorizationError","once","process","nextTick","utils_1","fromHostPort","proxyPort","rawSocket","destination","socks_1","existing_socket","timeout","proxy","type","userId","proxyUsername","password","proxyPassword","then","error"],"sources":["C:\\Users\\anshs\\OneDrive\\Documents\\Code\\WebDevelopement\\portfolioPersonal\\node_modules\\mongodb\\src\\cmap\\connect.ts"],"sourcesContent":["import type { Socket, SocketConnectOpts } from 'net';\nimport * as net from 'net';\nimport { SocksClient } from 'socks';\nimport type { ConnectionOptions as TLSConnectionOpts, TLSSocket } from 'tls';\nimport * as tls from 'tls';\n\nimport type { Document } from '../bson';\nimport { Int32 } from '../bson';\nimport { LEGACY_HELLO_COMMAND } from '../constants';\nimport {\n  MongoCompatibilityError,\n  MongoError,\n  MongoErrorLabel,\n  MongoInvalidArgumentError,\n  MongoNetworkError,\n  MongoNetworkTimeoutError,\n  MongoRuntimeError,\n  MongoServerError,\n  needsRetryableWriteLabel\n} from '../error';\nimport { Callback, ClientMetadata, HostAddress, makeClientMetadata, ns } from '../utils';\nimport { AuthContext, AuthProvider } from './auth/auth_provider';\nimport { GSSAPI } from './auth/gssapi';\nimport { MongoCR } from './auth/mongocr';\nimport { MongoDBAWS } from './auth/mongodb_aws';\nimport { Plain } from './auth/plain';\nimport { AuthMechanism } from './auth/providers';\nimport { ScramSHA1, ScramSHA256 } from './auth/scram';\nimport { X509 } from './auth/x509';\nimport { Connection, ConnectionOptions, CryptoConnection } from './connection';\nimport {\n  MAX_SUPPORTED_SERVER_VERSION,\n  MAX_SUPPORTED_WIRE_VERSION,\n  MIN_SUPPORTED_SERVER_VERSION,\n  MIN_SUPPORTED_WIRE_VERSION\n} from './wire_protocol/constants';\n\nconst AUTH_PROVIDERS = new Map<AuthMechanism | string, AuthProvider>([\n  [AuthMechanism.MONGODB_AWS, new MongoDBAWS()],\n  [AuthMechanism.MONGODB_CR, new MongoCR()],\n  [AuthMechanism.MONGODB_GSSAPI, new GSSAPI()],\n  [AuthMechanism.MONGODB_PLAIN, new Plain()],\n  [AuthMechanism.MONGODB_SCRAM_SHA1, new ScramSHA1()],\n  [AuthMechanism.MONGODB_SCRAM_SHA256, new ScramSHA256()],\n  [AuthMechanism.MONGODB_X509, new X509()]\n]);\n\n/** @public */\nexport type Stream = Socket | TLSSocket;\n\nexport function connect(options: ConnectionOptions, callback: Callback<Connection>): void {\n  makeConnection({ ...options, existingSocket: undefined }, (err, socket) => {\n    if (err || !socket) {\n      return callback(err);\n    }\n\n    let ConnectionType = options.connectionType ?? Connection;\n    if (options.autoEncrypter) {\n      ConnectionType = CryptoConnection;\n    }\n    performInitialHandshake(new ConnectionType(socket, options), options, callback);\n  });\n}\n\nfunction checkSupportedServer(hello: Document, options: ConnectionOptions) {\n  const serverVersionHighEnough =\n    hello &&\n    (typeof hello.maxWireVersion === 'number' || hello.maxWireVersion instanceof Int32) &&\n    hello.maxWireVersion >= MIN_SUPPORTED_WIRE_VERSION;\n  const serverVersionLowEnough =\n    hello &&\n    (typeof hello.minWireVersion === 'number' || hello.minWireVersion instanceof Int32) &&\n    hello.minWireVersion <= MAX_SUPPORTED_WIRE_VERSION;\n\n  if (serverVersionHighEnough) {\n    if (serverVersionLowEnough) {\n      return null;\n    }\n\n    const message = `Server at ${options.hostAddress} reports minimum wire version ${JSON.stringify(\n      hello.minWireVersion\n    )}, but this version of the Node.js Driver requires at most ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n    return new MongoCompatibilityError(message);\n  }\n\n  const message = `Server at ${options.hostAddress} reports maximum wire version ${\n    JSON.stringify(hello.maxWireVersion) ?? 0\n  }, but this version of the Node.js Driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION})`;\n  return new MongoCompatibilityError(message);\n}\n\nfunction performInitialHandshake(\n  conn: Connection,\n  options: ConnectionOptions,\n  _callback: Callback\n) {\n  const callback: Callback<Document> = function (err, ret) {\n    if (err && conn) {\n      conn.destroy();\n    }\n    _callback(err, ret);\n  };\n\n  const credentials = options.credentials;\n  if (credentials) {\n    if (\n      !(credentials.mechanism === AuthMechanism.MONGODB_DEFAULT) &&\n      !AUTH_PROVIDERS.get(credentials.mechanism)\n    ) {\n      callback(\n        new MongoInvalidArgumentError(`AuthMechanism '${credentials.mechanism}' not supported`)\n      );\n      return;\n    }\n  }\n\n  const authContext = new AuthContext(conn, credentials, options);\n  prepareHandshakeDocument(authContext, (err, handshakeDoc) => {\n    if (err || !handshakeDoc) {\n      return callback(err);\n    }\n\n    const handshakeOptions: Document = Object.assign({}, options);\n    if (typeof options.connectTimeoutMS === 'number') {\n      // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\n      handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;\n    }\n\n    const start = new Date().getTime();\n    conn.command(ns('admin.$cmd'), handshakeDoc, handshakeOptions, (err, response) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      if (response?.ok === 0) {\n        callback(new MongoServerError(response));\n        return;\n      }\n\n      if (!('isWritablePrimary' in response)) {\n        // Provide hello-style response document.\n        response.isWritablePrimary = response[LEGACY_HELLO_COMMAND];\n      }\n\n      if (response.helloOk) {\n        conn.helloOk = true;\n      }\n\n      const supportedServerErr = checkSupportedServer(response, options);\n      if (supportedServerErr) {\n        callback(supportedServerErr);\n        return;\n      }\n\n      if (options.loadBalanced) {\n        if (!response.serviceId) {\n          return callback(\n            new MongoCompatibilityError(\n              'Driver attempted to initialize in load balancing mode, ' +\n                'but the server does not support this mode.'\n            )\n          );\n        }\n      }\n\n      // NOTE: This is metadata attached to the connection while porting away from\n      //       handshake being done in the `Server` class. Likely, it should be\n      //       relocated, or at very least restructured.\n      conn.hello = response;\n      conn.lastHelloMS = new Date().getTime() - start;\n\n      if (!response.arbiterOnly && credentials) {\n        // store the response on auth context\n        authContext.response = response;\n\n        const resolvedCredentials = credentials.resolveAuthMechanism(response);\n        const provider = AUTH_PROVIDERS.get(resolvedCredentials.mechanism);\n        if (!provider) {\n          return callback(\n            new MongoInvalidArgumentError(\n              `No AuthProvider for ${resolvedCredentials.mechanism} defined.`\n            )\n          );\n        }\n        provider.auth(authContext, err => {\n          if (err) {\n            if (err instanceof MongoError) {\n              err.addErrorLabel(MongoErrorLabel.HandshakeError);\n              if (needsRetryableWriteLabel(err, response.maxWireVersion)) {\n                err.addErrorLabel(MongoErrorLabel.RetryableWriteError);\n              }\n            }\n            return callback(err);\n          }\n          callback(undefined, conn);\n        });\n\n        return;\n      }\n\n      callback(undefined, conn);\n    });\n  });\n}\n\nexport interface HandshakeDocument extends Document {\n  /**\n   * @deprecated Use hello instead\n   */\n  ismaster?: boolean;\n  hello?: boolean;\n  helloOk?: boolean;\n  client: ClientMetadata;\n  compression: string[];\n  saslSupportedMechs?: string;\n  loadBalanced?: boolean;\n}\n\n/**\n * @internal\n *\n * This function is only exposed for testing purposes.\n */\nexport function prepareHandshakeDocument(\n  authContext: AuthContext,\n  callback: Callback<HandshakeDocument>\n) {\n  const options = authContext.options;\n  const compressors = options.compressors ? options.compressors : [];\n  const { serverApi } = authContext.connection;\n\n  const handshakeDoc: HandshakeDocument = {\n    [serverApi?.version ? 'hello' : LEGACY_HELLO_COMMAND]: 1,\n    helloOk: true,\n    client: options.metadata || makeClientMetadata(options),\n    compression: compressors\n  };\n\n  if (options.loadBalanced === true) {\n    handshakeDoc.loadBalanced = true;\n  }\n\n  const credentials = authContext.credentials;\n  if (credentials) {\n    if (credentials.mechanism === AuthMechanism.MONGODB_DEFAULT && credentials.username) {\n      handshakeDoc.saslSupportedMechs = `${credentials.source}.${credentials.username}`;\n\n      const provider = AUTH_PROVIDERS.get(AuthMechanism.MONGODB_SCRAM_SHA256);\n      if (!provider) {\n        // This auth mechanism is always present.\n        return callback(\n          new MongoInvalidArgumentError(\n            `No AuthProvider for ${AuthMechanism.MONGODB_SCRAM_SHA256} defined.`\n          )\n        );\n      }\n      return provider.prepare(handshakeDoc, authContext, callback);\n    }\n    const provider = AUTH_PROVIDERS.get(credentials.mechanism);\n    if (!provider) {\n      return callback(\n        new MongoInvalidArgumentError(`No AuthProvider for ${credentials.mechanism} defined.`)\n      );\n    }\n    return provider.prepare(handshakeDoc, authContext, callback);\n  }\n  callback(undefined, handshakeDoc);\n}\n\n/** @public */\nexport const LEGAL_TLS_SOCKET_OPTIONS = [\n  'ALPNProtocols',\n  'ca',\n  'cert',\n  'checkServerIdentity',\n  'ciphers',\n  'crl',\n  'ecdhCurve',\n  'key',\n  'minDHSize',\n  'passphrase',\n  'pfx',\n  'rejectUnauthorized',\n  'secureContext',\n  'secureProtocol',\n  'servername',\n  'session'\n] as const;\n\n/** @public */\nexport const LEGAL_TCP_SOCKET_OPTIONS = [\n  'family',\n  'hints',\n  'localAddress',\n  'localPort',\n  'lookup'\n] as const;\n\nfunction parseConnectOptions(options: ConnectionOptions): SocketConnectOpts {\n  const hostAddress = options.hostAddress;\n  if (!hostAddress) throw new MongoInvalidArgumentError('Option \"hostAddress\" is required');\n\n  const result: Partial<net.TcpNetConnectOpts & net.IpcNetConnectOpts> = {};\n  for (const name of LEGAL_TCP_SOCKET_OPTIONS) {\n    if (options[name] != null) {\n      (result as Document)[name] = options[name];\n    }\n  }\n\n  if (typeof hostAddress.socketPath === 'string') {\n    result.path = hostAddress.socketPath;\n    return result as net.IpcNetConnectOpts;\n  } else if (typeof hostAddress.host === 'string') {\n    result.host = hostAddress.host;\n    result.port = hostAddress.port;\n    return result as net.TcpNetConnectOpts;\n  } else {\n    // This should never happen since we set up HostAddresses\n    // But if we don't throw here the socket could hang until timeout\n    // TODO(NODE-3483)\n    throw new MongoRuntimeError(`Unexpected HostAddress ${JSON.stringify(hostAddress)}`);\n  }\n}\n\ntype MakeConnectionOptions = ConnectionOptions & { existingSocket?: Stream };\n\nfunction parseSslOptions(options: MakeConnectionOptions): TLSConnectionOpts {\n  const result: TLSConnectionOpts = parseConnectOptions(options);\n  // Merge in valid SSL options\n  for (const name of LEGAL_TLS_SOCKET_OPTIONS) {\n    if (options[name] != null) {\n      (result as Document)[name] = options[name];\n    }\n  }\n\n  if (options.existingSocket) {\n    result.socket = options.existingSocket;\n  }\n\n  // Set default sni servername to be the same as host\n  if (result.servername == null && result.host && !net.isIP(result.host)) {\n    result.servername = result.host;\n  }\n\n  return result;\n}\n\nconst SOCKET_ERROR_EVENT_LIST = ['error', 'close', 'timeout', 'parseError'] as const;\ntype ErrorHandlerEventName = typeof SOCKET_ERROR_EVENT_LIST[number] | 'cancel';\nconst SOCKET_ERROR_EVENTS = new Set(SOCKET_ERROR_EVENT_LIST);\n\nfunction makeConnection(options: MakeConnectionOptions, _callback: Callback<Stream>) {\n  const useTLS = options.tls ?? false;\n  const keepAlive = options.keepAlive ?? true;\n  const socketTimeoutMS = options.socketTimeoutMS ?? Reflect.get(options, 'socketTimeout') ?? 0;\n  const noDelay = options.noDelay ?? true;\n  const connectTimeoutMS = options.connectTimeoutMS ?? 30000;\n  const rejectUnauthorized = options.rejectUnauthorized ?? true;\n  const keepAliveInitialDelay =\n    ((options.keepAliveInitialDelay ?? 120000) > socketTimeoutMS\n      ? Math.round(socketTimeoutMS / 2)\n      : options.keepAliveInitialDelay) ?? 120000;\n  const existingSocket = options.existingSocket;\n\n  let socket: Stream;\n  const callback: Callback<Stream> = function (err, ret) {\n    if (err && socket) {\n      socket.destroy();\n    }\n\n    _callback(err, ret);\n  };\n\n  if (options.proxyHost != null) {\n    // Currently, only Socks5 is supported.\n    return makeSocks5Connection(\n      {\n        ...options,\n        connectTimeoutMS // Should always be present for Socks5\n      },\n      callback\n    );\n  }\n\n  if (useTLS) {\n    const tlsSocket = tls.connect(parseSslOptions(options));\n    if (typeof tlsSocket.disableRenegotiation === 'function') {\n      tlsSocket.disableRenegotiation();\n    }\n    socket = tlsSocket;\n  } else if (existingSocket) {\n    // In the TLS case, parseSslOptions() sets options.socket to existingSocket,\n    // so we only need to handle the non-TLS case here (where existingSocket\n    // gives us all we need out of the box).\n    socket = existingSocket;\n  } else {\n    socket = net.createConnection(parseConnectOptions(options));\n  }\n\n  socket.setKeepAlive(keepAlive, keepAliveInitialDelay);\n  socket.setTimeout(connectTimeoutMS);\n  socket.setNoDelay(noDelay);\n\n  const connectEvent = useTLS ? 'secureConnect' : 'connect';\n  let cancellationHandler: (err: Error) => void;\n  function errorHandler(eventName: ErrorHandlerEventName) {\n    return (err: Error) => {\n      SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n      if (cancellationHandler && options.cancellationToken) {\n        options.cancellationToken.removeListener('cancel', cancellationHandler);\n      }\n\n      socket.removeListener(connectEvent, connectHandler);\n      callback(connectionFailureError(eventName, err));\n    };\n  }\n\n  function connectHandler() {\n    SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n    if (cancellationHandler && options.cancellationToken) {\n      options.cancellationToken.removeListener('cancel', cancellationHandler);\n    }\n\n    if ('authorizationError' in socket) {\n      if (socket.authorizationError && rejectUnauthorized) {\n        return callback(socket.authorizationError);\n      }\n    }\n\n    socket.setTimeout(socketTimeoutMS);\n    callback(undefined, socket);\n  }\n\n  SOCKET_ERROR_EVENTS.forEach(event => socket.once(event, errorHandler(event)));\n  if (options.cancellationToken) {\n    cancellationHandler = errorHandler('cancel');\n    options.cancellationToken.once('cancel', cancellationHandler);\n  }\n\n  if (existingSocket) {\n    process.nextTick(connectHandler);\n  } else {\n    socket.once(connectEvent, connectHandler);\n  }\n}\n\nfunction makeSocks5Connection(options: MakeConnectionOptions, callback: Callback<Stream>) {\n  const hostAddress = HostAddress.fromHostPort(\n    options.proxyHost ?? '', // proxyHost is guaranteed to set here\n    options.proxyPort ?? 1080\n  );\n\n  // First, connect to the proxy server itself:\n  makeConnection(\n    {\n      ...options,\n      hostAddress,\n      tls: false,\n      proxyHost: undefined\n    },\n    (err, rawSocket) => {\n      if (err) {\n        return callback(err);\n      }\n\n      const destination = parseConnectOptions(options) as net.TcpNetConnectOpts;\n      if (typeof destination.host !== 'string' || typeof destination.port !== 'number') {\n        return callback(\n          new MongoInvalidArgumentError('Can only make Socks5 connections to TCP hosts')\n        );\n      }\n\n      // Then, establish the Socks5 proxy connection:\n      SocksClient.createConnection({\n        existing_socket: rawSocket,\n        timeout: options.connectTimeoutMS,\n        command: 'connect',\n        destination: {\n          host: destination.host,\n          port: destination.port\n        },\n        proxy: {\n          // host and port are ignored because we pass existing_socket\n          host: 'iLoveJavaScript',\n          port: 0,\n          type: 5,\n          userId: options.proxyUsername || undefined,\n          password: options.proxyPassword || undefined\n        }\n      }).then(\n        ({ socket }) => {\n          // Finally, now treat the resulting duplex stream as the\n          // socket over which we send and receive wire protocol messages:\n          makeConnection(\n            {\n              ...options,\n              existingSocket: socket,\n              proxyHost: undefined\n            },\n            callback\n          );\n        },\n        error => callback(connectionFailureError('error', error))\n      );\n    }\n  );\n}\n\nfunction connectionFailureError(type: ErrorHandlerEventName, err: Error) {\n  switch (type) {\n    case 'error':\n      return new MongoNetworkError(err);\n    case 'timeout':\n      return new MongoNetworkTimeoutError('connection timed out');\n    case 'close':\n      return new MongoNetworkError('connection closed');\n    case 'cancel':\n      return new MongoNetworkError('connection establishment was cancelled');\n    default:\n      return new MongoNetworkError('unknown network error');\n  }\n}\n"]},"metadata":{},"sourceType":"script"}